
<!DOCTYPE html>
<html style="padding-left: 10%; padding-right: 10%;">
	<head>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<style>
table{border-collapse: collapse;}
td{border:1px solid #BBB;padding:4px;}
ul{list-style:none;margin:0;padding:0;}
li{margin:0;padding:0;}
		</style>
	</head>
	<body>
		<h1 id="top"><a href="https://github.com/konsumer/raylib-pointers">librlptr</a></h1>
		<ul>
			<li><a href="#unwrapped">unwrapped</a></li><li><a href="#wrapped">wrapped</a></li><li><a href="#struct_utils">struct_utils</a></li><li><a href="#defines">defines</a></li><li><a href="#structs">structs</a></li><li><a href="#aliases">aliases</a></li><li><a href="#enums">enums</a></li><li><a href="#callbacks">callbacks</a></li><li><a href="#functions">functions</a></li>
		</ul>
		<hr>
		
<h2 id=unwrapped><a href="#top">unwrapped</a></h2>
<table>
	<tr><th>name</th><th>description</th><th>returnType</th><th>params</th></tr>
	<tr><td><b>InitWindow</b></td><td>Initialize window and OpenGL context</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>title: const char *</li></ul></td></tr>
<tr><td><b>CloseWindow</b></td><td>Close window and unload OpenGL context</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowReady</b></td><td>Check if window has been initialized successfully</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowFullscreen</b></td><td>Check if window is currently fullscreen</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowHidden</b></td><td>Check if window is currently hidden (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowMinimized</b></td><td>Check if window is currently minimized (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowMaximized</b></td><td>Check if window is currently maximized (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowFocused</b></td><td>Check if window is currently focused (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowResized</b></td><td>Check if window has been resized last frame</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowState</b></td><td>Check if one specific window flag is enabled</td><td>bool</td><td><ul><li>flag: unsigned int</li></ul></td></tr>
<tr><td><b>SetWindowState</b></td><td>Set window configuration state using flags (only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>ClearWindowState</b></td><td>Clear window configuration state flags</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>ToggleFullscreen</b></td><td>Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>ToggleBorderlessWindowed</b></td><td>Toggle window state: borderless windowed (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>MaximizeWindow</b></td><td>Set window state: maximized, if resizable (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>MinimizeWindow</b></td><td>Set window state: minimized, if resizable (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>RestoreWindow</b></td><td>Set window state: not minimized/maximized (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>SetWindowTitle</b></td><td>Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB)</td><td>void</td><td><ul><li>title: const char *</li></ul></td></tr>
<tr><td><b>SetWindowPosition</b></td><td>Set window position on screen (only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>x: int</li>
<li>y: int</li></ul></td></tr>
<tr><td><b>SetWindowMonitor</b></td><td>Set monitor for the current window</td><td>void</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>SetWindowMinSize</b></td><td>Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>SetWindowMaxSize</b></td><td>Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>SetWindowSize</b></td><td>Set window dimensions</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>SetWindowOpacity</b></td><td>Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>opacity: float</li></ul></td></tr>
<tr><td><b>SetWindowFocused</b></td><td>Set window focused (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>GetWindowHandle</b></td><td>Get native window handle</td><td>void *</td><td><ul></ul></td></tr>
<tr><td><b>GetScreenWidth</b></td><td>Get current screen width</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetScreenHeight</b></td><td>Get current screen height</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetRenderWidth</b></td><td>Get current render width (it considers HiDPI)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetRenderHeight</b></td><td>Get current render height (it considers HiDPI)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetMonitorCount</b></td><td>Get number of connected monitors</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetCurrentMonitor</b></td><td>Get current connected monitor</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetMonitorWidth</b></td><td>Get specified monitor width (current video mode used by monitor)</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorHeight</b></td><td>Get specified monitor height (current video mode used by monitor)</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorPhysicalWidth</b></td><td>Get specified monitor physical width in millimetres</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorPhysicalHeight</b></td><td>Get specified monitor physical height in millimetres</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorRefreshRate</b></td><td>Get specified monitor refresh rate</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorName</b></td><td>Get the human-readable, UTF-8 encoded name of the specified monitor</td><td>const char *</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>SetClipboardText</b></td><td>Set clipboard text content</td><td>void</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>GetClipboardText</b></td><td>Get clipboard text content</td><td>const char *</td><td><ul></ul></td></tr>
<tr><td><b>EnableEventWaiting</b></td><td>Enable waiting for events on EndDrawing(), no automatic event polling</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>DisableEventWaiting</b></td><td>Disable waiting for events on EndDrawing(), automatic events polling</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>ShowCursor</b></td><td>Shows cursor</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>HideCursor</b></td><td>Hides cursor</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsCursorHidden</b></td><td>Check if cursor is not visible</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>EnableCursor</b></td><td>Enables cursor (unlock cursor)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>DisableCursor</b></td><td>Disables cursor (lock cursor)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsCursorOnScreen</b></td><td>Check if cursor is on the screen</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>BeginDrawing</b></td><td>Setup canvas (framebuffer) to start drawing</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>EndDrawing</b></td><td>End canvas drawing and swap buffers (double buffering)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>EndMode2D</b></td><td>Ends 2D mode with custom camera</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>EndMode3D</b></td><td>Ends 3D mode and returns to default 2D orthographic mode</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>EndTextureMode</b></td><td>Ends drawing to render texture</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>EndShaderMode</b></td><td>End custom shader drawing (use default shader)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginBlendMode</b></td><td>Begin blending mode (alpha, additive, multiplied, subtract, custom)</td><td>void</td><td><ul><li>mode: int</li></ul></td></tr>
<tr><td><b>EndBlendMode</b></td><td>End blending mode (reset to default: alpha blending)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginScissorMode</b></td><td>Begin scissor mode (define screen area for following drawing)</td><td>void</td><td><ul><li>x: int</li>
<li>y: int</li>
<li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>EndScissorMode</b></td><td>End scissor mode</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>EndVrStereoMode</b></td><td>End stereo rendering (requires VR simulator)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>SetTargetFPS</b></td><td>Set target FPS (maximum)</td><td>void</td><td><ul><li>fps: int</li></ul></td></tr>
<tr><td><b>GetFrameTime</b></td><td>Get time in seconds for last frame drawn (delta time)</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetTime</b></td><td>Get elapsed time in seconds since InitWindow()</td><td>double</td><td><ul></ul></td></tr>
<tr><td><b>GetFPS</b></td><td>Get current FPS</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>SwapScreenBuffer</b></td><td>Swap back buffer with front buffer (screen drawing)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>PollInputEvents</b></td><td>Register all input events</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>WaitTime</b></td><td>Wait for some time (halt program execution)</td><td>void</td><td><ul><li>seconds: double</li></ul></td></tr>
<tr><td><b>SetRandomSeed</b></td><td>Set the seed for the random number generator</td><td>void</td><td><ul><li>seed: unsigned int</li></ul></td></tr>
<tr><td><b>GetRandomValue</b></td><td>Get a random value between min and max (both included)</td><td>int</td><td><ul><li>min: int</li>
<li>max: int</li></ul></td></tr>
<tr><td><b>LoadRandomSequence</b></td><td>Load random values sequence, no values repeated</td><td>int *</td><td><ul><li>count: unsigned int</li>
<li>min: int</li>
<li>max: int</li></ul></td></tr>
<tr><td><b>UnloadRandomSequence</b></td><td>Unload random values sequence</td><td>void</td><td><ul><li>sequence: int *</li></ul></td></tr>
<tr><td><b>TakeScreenshot</b></td><td>Takes a screenshot of current screen (filename extension defines format)</td><td>void</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>SetConfigFlags</b></td><td>Setup init configuration flags (view FLAGS)</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>OpenURL</b></td><td>Open URL with default system browser (if available)</td><td>void</td><td><ul><li>url: const char *</li></ul></td></tr>
<tr><td><b>TraceLog</b></td><td>Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)</td><td>void</td><td><ul><li>logLevel: int</li>
<li>text: const char *</li>
<li>args: ...</li></ul></td></tr>
<tr><td><b>SetTraceLogLevel</b></td><td>Set the current threshold (minimum) log level</td><td>void</td><td><ul><li>logLevel: int</li></ul></td></tr>
<tr><td><b>MemAlloc</b></td><td>Internal memory allocator</td><td>void *</td><td><ul><li>size: unsigned int</li></ul></td></tr>
<tr><td><b>MemRealloc</b></td><td>Internal memory reallocator</td><td>void *</td><td><ul><li>ptr: void *</li>
<li>size: unsigned int</li></ul></td></tr>
<tr><td><b>MemFree</b></td><td>Internal memory free</td><td>void</td><td><ul><li>ptr: void *</li></ul></td></tr>
<tr><td><b>LoadFileData</b></td><td>Load file data as byte array (read)</td><td>unsigned char *</td><td><ul><li>fileName: const char *</li>
<li>dataSize: int *</li></ul></td></tr>
<tr><td><b>UnloadFileData</b></td><td>Unload file data allocated by LoadFileData()</td><td>void</td><td><ul><li>data: unsigned char *</li></ul></td></tr>
<tr><td><b>SaveFileData</b></td><td>Save data to file from byte array (write), returns true on success</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>data: void *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>ExportDataAsCode</b></td><td>Export data to code (.h), returns true on success</td><td>bool</td><td><ul><li>data: const unsigned char *</li>
<li>dataSize: int</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadFileText</b></td><td>Load text data from file (read), returns a '\0' terminated string</td><td>char *</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>UnloadFileText</b></td><td>Unload file text data allocated by LoadFileText()</td><td>void</td><td><ul><li>text: char *</li></ul></td></tr>
<tr><td><b>SaveFileText</b></td><td>Save text data to file (write), string must be '\0' terminated, returns true on success</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>text: char *</li></ul></td></tr>
<tr><td><b>FileExists</b></td><td>Check if file exists</td><td>bool</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>DirectoryExists</b></td><td>Check if a directory path exists</td><td>bool</td><td><ul><li>dirPath: const char *</li></ul></td></tr>
<tr><td><b>IsFileExtension</b></td><td>Check file extension (including point: .png, .wav)</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>ext: const char *</li></ul></td></tr>
<tr><td><b>GetFileLength</b></td><td>Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)</td><td>int</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>GetFileExtension</b></td><td>Get pointer to extension for a filename string (includes dot: '.png')</td><td>const char *</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>GetFileName</b></td><td>Get pointer to filename for a path string</td><td>const char *</td><td><ul><li>filePath: const char *</li></ul></td></tr>
<tr><td><b>GetFileNameWithoutExt</b></td><td>Get filename string without extension (uses static string)</td><td>const char *</td><td><ul><li>filePath: const char *</li></ul></td></tr>
<tr><td><b>GetDirectoryPath</b></td><td>Get full path for a given fileName with path (uses static string)</td><td>const char *</td><td><ul><li>filePath: const char *</li></ul></td></tr>
<tr><td><b>GetPrevDirectoryPath</b></td><td>Get previous directory path for a given path (uses static string)</td><td>const char *</td><td><ul><li>dirPath: const char *</li></ul></td></tr>
<tr><td><b>GetWorkingDirectory</b></td><td>Get current working directory (uses static string)</td><td>const char *</td><td><ul></ul></td></tr>
<tr><td><b>GetApplicationDirectory</b></td><td>Get the directory of the running application (uses static string)</td><td>const char *</td><td><ul></ul></td></tr>
<tr><td><b>ChangeDirectory</b></td><td>Change working directory, return true on success</td><td>bool</td><td><ul><li>dir: const char *</li></ul></td></tr>
<tr><td><b>IsPathFile</b></td><td>Check if a given path is a file or a directory</td><td>bool</td><td><ul><li>path: const char *</li></ul></td></tr>
<tr><td><b>IsFileDropped</b></td><td>Check if a file has been dropped into window</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>GetFileModTime</b></td><td>Get file modification time (last write time)</td><td>long</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>CompressData</b></td><td>Compress data (DEFLATE algorithm), memory must be MemFree()</td><td>unsigned char *</td><td><ul><li>data: const unsigned char *</li>
<li>dataSize: int</li>
<li>compDataSize: int *</li></ul></td></tr>
<tr><td><b>DecompressData</b></td><td>Decompress data (DEFLATE algorithm), memory must be MemFree()</td><td>unsigned char *</td><td><ul><li>compData: const unsigned char *</li>
<li>compDataSize: int</li>
<li>dataSize: int *</li></ul></td></tr>
<tr><td><b>EncodeDataBase64</b></td><td>Encode data to Base64 string, memory must be MemFree()</td><td>char *</td><td><ul><li>data: const unsigned char *</li>
<li>dataSize: int</li>
<li>outputSize: int *</li></ul></td></tr>
<tr><td><b>DecodeDataBase64</b></td><td>Decode Base64 string data, memory must be MemFree()</td><td>unsigned char *</td><td><ul><li>data: const unsigned char *</li>
<li>outputSize: int *</li></ul></td></tr>
<tr><td><b>SetAutomationEventBaseFrame</b></td><td>Set automation event internal base frame to start recording</td><td>void</td><td><ul><li>frame: int</li></ul></td></tr>
<tr><td><b>StartAutomationEventRecording</b></td><td>Start recording automation events (AutomationEventList must be set)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>StopAutomationEventRecording</b></td><td>Stop recording automation events</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsKeyPressed</b></td><td>Check if a key has been pressed once</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyPressedRepeat</b></td><td>Check if a key has been pressed again (Only PLATFORM_DESKTOP)</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyDown</b></td><td>Check if a key is being pressed</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyReleased</b></td><td>Check if a key has been released once</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyUp</b></td><td>Check if a key is NOT being pressed</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>GetKeyPressed</b></td><td>Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetCharPressed</b></td><td>Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>SetExitKey</b></td><td>Set a custom key to exit program (default is ESC)</td><td>void</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsGamepadAvailable</b></td><td>Check if a gamepad is available</td><td>bool</td><td><ul><li>gamepad: int</li></ul></td></tr>
<tr><td><b>GetGamepadName</b></td><td>Get gamepad internal name id</td><td>const char *</td><td><ul><li>gamepad: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonPressed</b></td><td>Check if a gamepad button has been pressed once</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonDown</b></td><td>Check if a gamepad button is being pressed</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonReleased</b></td><td>Check if a gamepad button has been released once</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonUp</b></td><td>Check if a gamepad button is NOT being pressed</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>GetGamepadButtonPressed</b></td><td>Get the last gamepad button pressed</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetGamepadAxisCount</b></td><td>Get gamepad axis count for a gamepad</td><td>int</td><td><ul><li>gamepad: int</li></ul></td></tr>
<tr><td><b>GetGamepadAxisMovement</b></td><td>Get axis movement value for a gamepad axis</td><td>float</td><td><ul><li>gamepad: int</li>
<li>axis: int</li></ul></td></tr>
<tr><td><b>SetGamepadMappings</b></td><td>Set internal gamepad mappings (SDL_GameControllerDB)</td><td>int</td><td><ul><li>mappings: const char *</li></ul></td></tr>
<tr><td><b>IsMouseButtonPressed</b></td><td>Check if a mouse button has been pressed once</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>IsMouseButtonDown</b></td><td>Check if a mouse button is being pressed</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>IsMouseButtonReleased</b></td><td>Check if a mouse button has been released once</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>IsMouseButtonUp</b></td><td>Check if a mouse button is NOT being pressed</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>GetMouseX</b></td><td>Get mouse position X</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetMouseY</b></td><td>Get mouse position Y</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>SetMousePosition</b></td><td>Set mouse position XY</td><td>void</td><td><ul><li>x: int</li>
<li>y: int</li></ul></td></tr>
<tr><td><b>SetMouseOffset</b></td><td>Set mouse offset</td><td>void</td><td><ul><li>offsetX: int</li>
<li>offsetY: int</li></ul></td></tr>
<tr><td><b>SetMouseScale</b></td><td>Set mouse scaling</td><td>void</td><td><ul><li>scaleX: float</li>
<li>scaleY: float</li></ul></td></tr>
<tr><td><b>GetMouseWheelMove</b></td><td>Get mouse wheel movement for X or Y, whichever is larger</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>SetMouseCursor</b></td><td>Set mouse cursor</td><td>void</td><td><ul><li>cursor: int</li></ul></td></tr>
<tr><td><b>GetTouchX</b></td><td>Get touch position X for touch point 0 (relative to screen size)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetTouchY</b></td><td>Get touch position Y for touch point 0 (relative to screen size)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetTouchPointId</b></td><td>Get touch point identifier for given index</td><td>int</td><td><ul><li>index: int</li></ul></td></tr>
<tr><td><b>GetTouchPointCount</b></td><td>Get number of touch points</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>SetGesturesEnabled</b></td><td>Enable a set of gestures using flags</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>IsGestureDetected</b></td><td>Check if a gesture have been detected</td><td>bool</td><td><ul><li>gesture: unsigned int</li></ul></td></tr>
<tr><td><b>GetGestureDetected</b></td><td>Get latest detected gesture</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetGestureHoldDuration</b></td><td>Get gesture hold time in milliseconds</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetGestureDragAngle</b></td><td>Get gesture drag angle</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetGesturePinchAngle</b></td><td>Get gesture pinch angle</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetPixelDataSize</b></td><td>Get pixel data size in bytes for certain format</td><td>int</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>format: int</li></ul></td></tr>
<tr><td><b>DrawFPS</b></td><td>Draw current FPS</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li></ul></td></tr>
<tr><td><b>SetTextLineSpacing</b></td><td>Set vertical line spacing when drawing with line-breaks</td><td>void</td><td><ul><li>spacing: int</li></ul></td></tr>
<tr><td><b>MeasureText</b></td><td>Measure string width for default font</td><td>int</td><td><ul><li>text: const char *</li>
<li>fontSize: int</li></ul></td></tr>
<tr><td><b>LoadUTF8</b></td><td>Load UTF-8 text encoded from codepoints array</td><td>char *</td><td><ul><li>codepoints: const int *</li>
<li>length: int</li></ul></td></tr>
<tr><td><b>UnloadUTF8</b></td><td>Unload UTF-8 text encoded from codepoints array</td><td>void</td><td><ul><li>text: char *</li></ul></td></tr>
<tr><td><b>LoadCodepoints</b></td><td>Load all codepoints from a UTF-8 text string, codepoints count returned by parameter</td><td>int *</td><td><ul><li>text: const char *</li>
<li>count: int *</li></ul></td></tr>
<tr><td><b>UnloadCodepoints</b></td><td>Unload codepoints data from memory</td><td>void</td><td><ul><li>codepoints: int *</li></ul></td></tr>
<tr><td><b>GetCodepointCount</b></td><td>Get total number of codepoints in a UTF-8 encoded string</td><td>int</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>GetCodepoint</b></td><td>Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure</td><td>int</td><td><ul><li>text: const char *</li>
<li>codepointSize: int *</li></ul></td></tr>
<tr><td><b>GetCodepointNext</b></td><td>Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure</td><td>int</td><td><ul><li>text: const char *</li>
<li>codepointSize: int *</li></ul></td></tr>
<tr><td><b>GetCodepointPrevious</b></td><td>Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure</td><td>int</td><td><ul><li>text: const char *</li>
<li>codepointSize: int *</li></ul></td></tr>
<tr><td><b>CodepointToUTF8</b></td><td>Encode one codepoint into UTF-8 byte array (array length returned as parameter)</td><td>const char *</td><td><ul><li>codepoint: int</li>
<li>utf8Size: int *</li></ul></td></tr>
<tr><td><b>TextCopy</b></td><td>Copy one string to another, returns bytes copied</td><td>int</td><td><ul><li>dst: char *</li>
<li>src: const char *</li></ul></td></tr>
<tr><td><b>TextIsEqual</b></td><td>Check if two text string are equal</td><td>bool</td><td><ul><li>text1: const char *</li>
<li>text2: const char *</li></ul></td></tr>
<tr><td><b>TextLength</b></td><td>Get text length, checks for '\0' ending</td><td>unsigned int</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextFormat</b></td><td>Text formatting with variables (sprintf() style)</td><td>const char *</td><td><ul><li>text: const char *</li>
<li>args: ...</li></ul></td></tr>
<tr><td><b>TextSubtext</b></td><td>Get a piece of a text string</td><td>const char *</td><td><ul><li>text: const char *</li>
<li>position: int</li>
<li>length: int</li></ul></td></tr>
<tr><td><b>TextReplace</b></td><td>Replace text string (WARNING: memory must be freed!)</td><td>char *</td><td><ul><li>text: char *</li>
<li>replace: const char *</li>
<li>by: const char *</li></ul></td></tr>
<tr><td><b>TextInsert</b></td><td>Insert text in a position (WARNING: memory must be freed!)</td><td>char *</td><td><ul><li>text: const char *</li>
<li>insert: const char *</li>
<li>position: int</li></ul></td></tr>
<tr><td><b>TextJoin</b></td><td>Join text strings with delimiter</td><td>const char *</td><td><ul><li>textList: const char **</li>
<li>count: int</li>
<li>delimiter: const char *</li></ul></td></tr>
<tr><td><b>TextSplit</b></td><td>Split text into multiple strings</td><td>const char **</td><td><ul><li>text: const char *</li>
<li>delimiter: char</li>
<li>count: int *</li></ul></td></tr>
<tr><td><b>TextAppend</b></td><td>Append text at specific position and move cursor!</td><td>void</td><td><ul><li>text: char *</li>
<li>append: const char *</li>
<li>position: int *</li></ul></td></tr>
<tr><td><b>TextFindIndex</b></td><td>Find first text occurrence within a string</td><td>int</td><td><ul><li>text: const char *</li>
<li>find: const char *</li></ul></td></tr>
<tr><td><b>TextToUpper</b></td><td>Get upper case version of provided string</td><td>const char *</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextToLower</b></td><td>Get lower case version of provided string</td><td>const char *</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextToPascal</b></td><td>Get Pascal case notation version of provided string</td><td>const char *</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextToInteger</b></td><td>Get integer value from text (negative values not supported)</td><td>int</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>DrawGrid</b></td><td>Draw a grid (centered at (0, 0, 0))</td><td>void</td><td><ul><li>slices: int</li>
<li>spacing: float</li></ul></td></tr>
<tr><td><b>InitAudioDevice</b></td><td>Initialize audio device and context</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>CloseAudioDevice</b></td><td>Close the audio device and context</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsAudioDeviceReady</b></td><td>Check if audio device has been initialized successfully</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>SetMasterVolume</b></td><td>Set master volume (listener)</td><td>void</td><td><ul><li>volume: float</li></ul></td></tr>
<tr><td><b>GetMasterVolume</b></td><td>Get master volume (listener)</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>UnloadWaveSamples</b></td><td>Unload samples data loaded with LoadWaveSamples()</td><td>void</td><td><ul><li>samples: float *</li></ul></td></tr>
<tr><td><b>SetAudioStreamBufferSizeDefault</b></td><td>Default size for new audio streams</td><td>void</td><td><ul><li>size: int</li></ul></td></tr>
</table>
  <br>

<h2 id=wrapped><a href="#top">wrapped</a></h2>
<table>
	<tr><th>name</th><th>description</th><th>original</th><th>returnType</th><th>params</th></tr>
	<tr><td><b>wrapped_SetWindowIcon</b></td><td>Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)</td><td>SetWindowIcon</td><td>void</td><td><ul><li>image: Image*</li></ul></td></tr>
<tr><td><b>wrapped_SetWindowIcons</b></td><td>Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)</td><td>SetWindowIcons</td><td>void</td><td><ul><li>images: Image **</li>
<li>count: int</li></ul></td></tr>
<tr><td><b>wrapped_GetMonitorPosition</b></td><td>Get specified monitor position</td><td>GetMonitorPosition</td><td>Vector2*</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>wrapped_GetWindowPosition</b></td><td>Get window position XY on monitor</td><td>GetWindowPosition</td><td>Vector2*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_GetWindowScaleDPI</b></td><td>Get window scale DPI factor</td><td>GetWindowScaleDPI</td><td>Vector2*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_ClearBackground</b></td><td>Set background color (framebuffer clear color)</td><td>ClearBackground</td><td>void</td><td><ul><li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_BeginMode2D</b></td><td>Begin 2D mode with custom camera (2D)</td><td>BeginMode2D</td><td>void</td><td><ul><li>camera: Camera2D*</li></ul></td></tr>
<tr><td><b>wrapped_BeginMode3D</b></td><td>Begin 3D mode with custom camera (3D)</td><td>BeginMode3D</td><td>void</td><td><ul><li>camera: Camera3D*</li></ul></td></tr>
<tr><td><b>wrapped_BeginTextureMode</b></td><td>Begin drawing to render texture</td><td>BeginTextureMode</td><td>void</td><td><ul><li>target: RenderTexture2D*</li></ul></td></tr>
<tr><td><b>wrapped_BeginShaderMode</b></td><td>Begin custom shader drawing</td><td>BeginShaderMode</td><td>void</td><td><ul><li>shader: Shader*</li></ul></td></tr>
<tr><td><b>wrapped_BeginVrStereoMode</b></td><td>Begin stereo rendering (requires VR simulator)</td><td>BeginVrStereoMode</td><td>void</td><td><ul><li>config: VrStereoConfig*</li></ul></td></tr>
<tr><td><b>wrapped_LoadVrStereoConfig</b></td><td>Load VR stereo config for VR simulator device parameters</td><td>LoadVrStereoConfig</td><td>VrStereoConfig*</td><td><ul><li>device: VrDeviceInfo*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadVrStereoConfig</b></td><td>Unload VR stereo config</td><td>UnloadVrStereoConfig</td><td>void</td><td><ul><li>config: VrStereoConfig*</li></ul></td></tr>
<tr><td><b>wrapped_LoadShader</b></td><td>Load shader from files and bind default locations</td><td>LoadShader</td><td>Shader*</td><td><ul><li>vsFileName: const char *</li>
<li>fsFileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadShaderFromMemory</b></td><td>Load shader from code strings and bind default locations</td><td>LoadShaderFromMemory</td><td>Shader*</td><td><ul><li>vsCode: const char *</li>
<li>fsCode: const char *</li></ul></td></tr>
<tr><td><b>wrapped_IsShaderReady</b></td><td>Check if a shader is ready</td><td>IsShaderReady</td><td>bool</td><td><ul><li>shader: Shader*</li></ul></td></tr>
<tr><td><b>wrapped_GetShaderLocation</b></td><td>Get shader uniform location</td><td>GetShaderLocation</td><td>int</td><td><ul><li>shader: Shader*</li>
<li>uniformName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_GetShaderLocationAttrib</b></td><td>Get shader attribute location</td><td>GetShaderLocationAttrib</td><td>int</td><td><ul><li>shader: Shader*</li>
<li>attribName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_SetShaderValue</b></td><td>Set shader uniform value</td><td>SetShaderValue</td><td>void</td><td><ul><li>shader: Shader*</li>
<li>locIndex: int</li>
<li>value: const void *</li>
<li>uniformType: int</li></ul></td></tr>
<tr><td><b>wrapped_SetShaderValueV</b></td><td>Set shader uniform value vector</td><td>SetShaderValueV</td><td>void</td><td><ul><li>shader: Shader*</li>
<li>locIndex: int</li>
<li>value: const void *</li>
<li>uniformType: int</li>
<li>count: int</li></ul></td></tr>
<tr><td><b>wrapped_SetShaderValueMatrix</b></td><td>Set shader uniform value (matrix 4x4)</td><td>SetShaderValueMatrix</td><td>void</td><td><ul><li>shader: Shader*</li>
<li>locIndex: int</li>
<li>mat: Matrix*</li></ul></td></tr>
<tr><td><b>wrapped_SetShaderValueTexture</b></td><td>Set shader uniform value for texture (sampler2d)</td><td>SetShaderValueTexture</td><td>void</td><td><ul><li>shader: Shader*</li>
<li>locIndex: int</li>
<li>texture: Texture2D*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadShader</b></td><td>Unload shader from GPU memory (VRAM)</td><td>UnloadShader</td><td>void</td><td><ul><li>shader: Shader*</li></ul></td></tr>
<tr><td><b>wrapped_GetMouseRay</b></td><td>Get a ray trace from mouse position</td><td>GetMouseRay</td><td>Ray*</td><td><ul><li>mousePosition: Vector2*</li>
<li>camera: Camera*</li></ul></td></tr>
<tr><td><b>wrapped_GetCameraMatrix</b></td><td>Get camera transform matrix (view matrix)</td><td>GetCameraMatrix</td><td>Matrix*</td><td><ul><li>camera: Camera*</li></ul></td></tr>
<tr><td><b>wrapped_GetCameraMatrix2D</b></td><td>Get camera 2d transform matrix</td><td>GetCameraMatrix2D</td><td>Matrix*</td><td><ul><li>camera: Camera2D*</li></ul></td></tr>
<tr><td><b>wrapped_GetWorldToScreen</b></td><td>Get the screen space position for a 3d world space position</td><td>GetWorldToScreen</td><td>Vector2*</td><td><ul><li>position: Vector3*</li>
<li>camera: Camera*</li></ul></td></tr>
<tr><td><b>wrapped_GetScreenToWorld2D</b></td><td>Get the world space position for a 2d camera screen space position</td><td>GetScreenToWorld2D</td><td>Vector2*</td><td><ul><li>position: Vector2*</li>
<li>camera: Camera2D*</li></ul></td></tr>
<tr><td><b>wrapped_GetWorldToScreenEx</b></td><td>Get size position for a 3d world space position</td><td>GetWorldToScreenEx</td><td>Vector2*</td><td><ul><li>position: Vector3*</li>
<li>camera: Camera*</li>
<li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>wrapped_GetWorldToScreen2D</b></td><td>Get the screen space position for a 2d camera world space position</td><td>GetWorldToScreen2D</td><td>Vector2*</td><td><ul><li>position: Vector2*</li>
<li>camera: Camera2D*</li></ul></td></tr>
<tr><td><b>wrapped_SetTraceLogCallback</b></td><td>Set custom trace log</td><td>SetTraceLogCallback</td><td>void</td><td><ul><li>callback: TraceLogCallback*</li></ul></td></tr>
<tr><td><b>wrapped_SetLoadFileDataCallback</b></td><td>Set custom file binary data loader</td><td>SetLoadFileDataCallback</td><td>void</td><td><ul><li>callback: LoadFileDataCallback*</li></ul></td></tr>
<tr><td><b>wrapped_SetSaveFileDataCallback</b></td><td>Set custom file binary data saver</td><td>SetSaveFileDataCallback</td><td>void</td><td><ul><li>callback: SaveFileDataCallback*</li></ul></td></tr>
<tr><td><b>wrapped_SetLoadFileTextCallback</b></td><td>Set custom file text data loader</td><td>SetLoadFileTextCallback</td><td>void</td><td><ul><li>callback: LoadFileTextCallback*</li></ul></td></tr>
<tr><td><b>wrapped_SetSaveFileTextCallback</b></td><td>Set custom file text data saver</td><td>SetSaveFileTextCallback</td><td>void</td><td><ul><li>callback: SaveFileTextCallback*</li></ul></td></tr>
<tr><td><b>wrapped_LoadDirectoryFiles</b></td><td>Load directory filepaths</td><td>LoadDirectoryFiles</td><td>FilePathList*</td><td><ul><li>dirPath: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadDirectoryFilesEx</b></td><td>Load directory filepaths with extension filtering and recursive directory scan</td><td>LoadDirectoryFilesEx</td><td>FilePathList*</td><td><ul><li>basePath: const char *</li>
<li>filter: const char *</li>
<li>scanSubdirs: bool</li></ul></td></tr>
<tr><td><b>wrapped_UnloadDirectoryFiles</b></td><td>Unload filepaths</td><td>UnloadDirectoryFiles</td><td>void</td><td><ul><li>files: FilePathList*</li></ul></td></tr>
<tr><td><b>wrapped_LoadDroppedFiles</b></td><td>Load dropped filepaths</td><td>LoadDroppedFiles</td><td>FilePathList*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_UnloadDroppedFiles</b></td><td>Unload dropped filepaths</td><td>UnloadDroppedFiles</td><td>void</td><td><ul><li>files: FilePathList*</li></ul></td></tr>
<tr><td><b>wrapped_GetMousePosition</b></td><td>Get mouse position XY</td><td>GetMousePosition</td><td>Vector2*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_GetMouseDelta</b></td><td>Get mouse delta between frames</td><td>GetMouseDelta</td><td>Vector2*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_GetMouseWheelMoveV</b></td><td>Get mouse wheel movement for both X and Y</td><td>GetMouseWheelMoveV</td><td>Vector2*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_GetTouchPosition</b></td><td>Get touch position XY for a touch point index (relative to screen size)</td><td>GetTouchPosition</td><td>Vector2*</td><td><ul><li>index: int</li></ul></td></tr>
<tr><td><b>wrapped_GetGestureDragVector</b></td><td>Get gesture drag vector</td><td>GetGestureDragVector</td><td>Vector2*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_GetGesturePinchVector</b></td><td>Get gesture pinch delta</td><td>GetGesturePinchVector</td><td>Vector2*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_UpdateCamera</b></td><td>Update camera position for selected mode</td><td>UpdateCamera</td><td>void</td><td><ul><li>camera: Camera **</li>
<li>mode: int</li></ul></td></tr>
<tr><td><b>wrapped_UpdateCameraPro</b></td><td>Update camera movement/rotation</td><td>UpdateCameraPro</td><td>void</td><td><ul><li>camera: Camera **</li>
<li>movement: Vector3*</li>
<li>rotation: Vector3*</li>
<li>zoom: float</li></ul></td></tr>
<tr><td><b>wrapped_SetShapesTexture</b></td><td>Set texture and rectangle to be used on shapes drawing</td><td>SetShapesTexture</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>source: Rectangle*</li></ul></td></tr>
<tr><td><b>wrapped_DrawPixel</b></td><td>Draw a pixel</td><td>DrawPixel</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawPixelV</b></td><td>Draw a pixel (Vector version)</td><td>DrawPixelV</td><td>void</td><td><ul><li>position: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawLine</b></td><td>Draw a line</td><td>DrawLine</td><td>void</td><td><ul><li>startPosX: int</li>
<li>startPosY: int</li>
<li>endPosX: int</li>
<li>endPosY: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawLineV</b></td><td>Draw a line (using gl lines)</td><td>DrawLineV</td><td>void</td><td><ul><li>startPos: Vector2*</li>
<li>endPos: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawLineEx</b></td><td>Draw a line (using triangles/quads)</td><td>DrawLineEx</td><td>void</td><td><ul><li>startPos: Vector2*</li>
<li>endPos: Vector2*</li>
<li>thick: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawLineStrip</b></td><td>Draw lines sequence (using gl lines)</td><td>DrawLineStrip</td><td>void</td><td><ul><li>points: Vector2 **</li>
<li>pointCount: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCircle</b></td><td>Draw a color-filled circle</td><td>DrawCircle</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radius: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCircleSector</b></td><td>Draw a piece of a circle</td><td>DrawCircleSector</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>radius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCircleSectorLines</b></td><td>Draw circle sector outline</td><td>DrawCircleSectorLines</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>radius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCircleGradient</b></td><td>Draw a gradient-filled circle</td><td>DrawCircleGradient</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radius: float</li>
<li>color1: Color*</li>
<li>color2: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCircleV</b></td><td>Draw a color-filled circle (Vector version)</td><td>DrawCircleV</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>radius: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCircleLines</b></td><td>Draw circle outline</td><td>DrawCircleLines</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radius: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawEllipse</b></td><td>Draw ellipse</td><td>DrawEllipse</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radiusH: float</li>
<li>radiusV: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawEllipseLines</b></td><td>Draw ellipse outline</td><td>DrawEllipseLines</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radiusH: float</li>
<li>radiusV: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRing</b></td><td>Draw ring</td><td>DrawRing</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>innerRadius: float</li>
<li>outerRadius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRingLines</b></td><td>Draw ring outline</td><td>DrawRingLines</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>innerRadius: float</li>
<li>outerRadius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangle</b></td><td>Draw a color-filled rectangle</td><td>DrawRectangle</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleV</b></td><td>Draw a color-filled rectangle (Vector version)</td><td>DrawRectangleV</td><td>void</td><td><ul><li>position: Vector2*</li>
<li>size: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleRec</b></td><td>Draw a color-filled rectangle</td><td>DrawRectangleRec</td><td>void</td><td><ul><li>rec: Rectangle*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectanglePro</b></td><td>Draw a color-filled rectangle with pro parameters</td><td>DrawRectanglePro</td><td>void</td><td><ul><li>rec: Rectangle*</li>
<li>origin: Vector2*</li>
<li>rotation: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleGradientV</b></td><td>Draw a vertical-gradient-filled rectangle</td><td>DrawRectangleGradientV</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color1: Color*</li>
<li>color2: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleGradientH</b></td><td>Draw a horizontal-gradient-filled rectangle</td><td>DrawRectangleGradientH</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color1: Color*</li>
<li>color2: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleGradientEx</b></td><td>Draw a gradient-filled rectangle with custom vertex colors</td><td>DrawRectangleGradientEx</td><td>void</td><td><ul><li>rec: Rectangle*</li>
<li>col1: Color*</li>
<li>col2: Color*</li>
<li>col3: Color*</li>
<li>col4: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleLines</b></td><td>Draw rectangle outline</td><td>DrawRectangleLines</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleLinesEx</b></td><td>Draw rectangle outline with extended parameters</td><td>DrawRectangleLinesEx</td><td>void</td><td><ul><li>rec: Rectangle*</li>
<li>lineThick: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleRounded</b></td><td>Draw rectangle with rounded edges</td><td>DrawRectangleRounded</td><td>void</td><td><ul><li>rec: Rectangle*</li>
<li>roundness: float</li>
<li>segments: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRectangleRoundedLines</b></td><td>Draw rectangle with rounded edges outline</td><td>DrawRectangleRoundedLines</td><td>void</td><td><ul><li>rec: Rectangle*</li>
<li>roundness: float</li>
<li>segments: int</li>
<li>lineThick: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTriangle</b></td><td>Draw a color-filled triangle (vertex in counter-clockwise order!)</td><td>DrawTriangle</td><td>void</td><td><ul><li>v1: Vector2*</li>
<li>v2: Vector2*</li>
<li>v3: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTriangleLines</b></td><td>Draw triangle outline (vertex in counter-clockwise order!)</td><td>DrawTriangleLines</td><td>void</td><td><ul><li>v1: Vector2*</li>
<li>v2: Vector2*</li>
<li>v3: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTriangleFan</b></td><td>Draw a triangle fan defined by points (first vertex is the center)</td><td>DrawTriangleFan</td><td>void</td><td><ul><li>points: Vector2 **</li>
<li>pointCount: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTriangleStrip</b></td><td>Draw a triangle strip defined by points</td><td>DrawTriangleStrip</td><td>void</td><td><ul><li>points: Vector2 **</li>
<li>pointCount: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawPoly</b></td><td>Draw a regular polygon (Vector version)</td><td>DrawPoly</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>sides: int</li>
<li>radius: float</li>
<li>rotation: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawPolyLines</b></td><td>Draw a polygon outline of n sides</td><td>DrawPolyLines</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>sides: int</li>
<li>radius: float</li>
<li>rotation: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawPolyLinesEx</b></td><td>Draw a polygon outline of n sides with extended parameters</td><td>DrawPolyLinesEx</td><td>void</td><td><ul><li>center: Vector2*</li>
<li>sides: int</li>
<li>radius: float</li>
<li>rotation: float</li>
<li>lineThick: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionRecs</b></td><td>Check collision between two rectangles</td><td>CheckCollisionRecs</td><td>bool</td><td><ul><li>rec1: Rectangle*</li>
<li>rec2: Rectangle*</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionCircles</b></td><td>Check collision between two circles</td><td>CheckCollisionCircles</td><td>bool</td><td><ul><li>center1: Vector2*</li>
<li>radius1: float</li>
<li>center2: Vector2*</li>
<li>radius2: float</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionCircleRec</b></td><td>Check collision between circle and rectangle</td><td>CheckCollisionCircleRec</td><td>bool</td><td><ul><li>center: Vector2*</li>
<li>radius: float</li>
<li>rec: Rectangle*</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionPointRec</b></td><td>Check if point is inside rectangle</td><td>CheckCollisionPointRec</td><td>bool</td><td><ul><li>point: Vector2*</li>
<li>rec: Rectangle*</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionPointCircle</b></td><td>Check if point is inside circle</td><td>CheckCollisionPointCircle</td><td>bool</td><td><ul><li>point: Vector2*</li>
<li>center: Vector2*</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionPointTriangle</b></td><td>Check if point is inside a triangle</td><td>CheckCollisionPointTriangle</td><td>bool</td><td><ul><li>point: Vector2*</li>
<li>p1: Vector2*</li>
<li>p2: Vector2*</li>
<li>p3: Vector2*</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionPointPoly</b></td><td>Check if point is within a polygon described by array of vertices</td><td>CheckCollisionPointPoly</td><td>bool</td><td><ul><li>point: Vector2*</li>
<li>points: Vector2 **</li>
<li>pointCount: int</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionLines</b></td><td>Check the collision between two lines defined by two points each, returns collision point by reference</td><td>CheckCollisionLines</td><td>bool</td><td><ul><li>startPos1: Vector2*</li>
<li>endPos1: Vector2*</li>
<li>startPos2: Vector2*</li>
<li>endPos2: Vector2*</li>
<li>collisionPoint: Vector2 **</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionPointLine</b></td><td>Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]</td><td>CheckCollisionPointLine</td><td>bool</td><td><ul><li>point: Vector2*</li>
<li>p1: Vector2*</li>
<li>p2: Vector2*</li>
<li>threshold: int</li></ul></td></tr>
<tr><td><b>wrapped_GetCollisionRec</b></td><td>Get collision rectangle for two rectangles collision</td><td>GetCollisionRec</td><td>Rectangle*</td><td><ul><li>rec1: Rectangle*</li>
<li>rec2: Rectangle*</li></ul></td></tr>
<tr><td><b>wrapped_LoadImage</b></td><td>Load image from file into CPU memory (RAM)</td><td>LoadImage</td><td>Image*</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadImageRaw</b></td><td>Load image from RAW file data</td><td>LoadImageRaw</td><td>Image*</td><td><ul><li>fileName: const char *</li>
<li>width: int</li>
<li>height: int</li>
<li>format: int</li>
<li>headerSize: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadImageSvg</b></td><td>Load image from SVG file data or string with specified size</td><td>LoadImageSvg</td><td>Image*</td><td><ul><li>fileNameOrString: const char *</li>
<li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadImageAnim</b></td><td>Load image sequence from file (frames appended to image.data)</td><td>LoadImageAnim</td><td>Image*</td><td><ul><li>fileName: const char *</li>
<li>frames: int *</li></ul></td></tr>
<tr><td><b>wrapped_LoadImageFromMemory</b></td><td>Load image from memory buffer, fileType refers to extension: i.e. '.png'</td><td>LoadImageFromMemory</td><td>Image*</td><td><ul><li>fileType: const char *</li>
<li>fileData: const unsigned char *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadImageFromTexture</b></td><td>Load image from GPU texture data</td><td>LoadImageFromTexture</td><td>Image*</td><td><ul><li>texture: Texture2D*</li></ul></td></tr>
<tr><td><b>wrapped_LoadImageFromScreen</b></td><td>Load image from screen buffer and (screenshot)</td><td>LoadImageFromScreen</td><td>Image*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_IsImageReady</b></td><td>Check if an image is ready</td><td>IsImageReady</td><td>bool</td><td><ul><li>image: Image*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadImage</b></td><td>Unload image from CPU memory (RAM)</td><td>UnloadImage</td><td>void</td><td><ul><li>image: Image*</li></ul></td></tr>
<tr><td><b>wrapped_ExportImage</b></td><td>Export image data to file, returns true on success</td><td>ExportImage</td><td>bool</td><td><ul><li>image: Image*</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_ExportImageToMemory</b></td><td>Export image to memory buffer</td><td>ExportImageToMemory</td><td>unsigned char *</td><td><ul><li>image: Image*</li>
<li>fileType: const char *</li>
<li>fileSize: int *</li></ul></td></tr>
<tr><td><b>wrapped_ExportImageAsCode</b></td><td>Export image as code file defining an array of bytes, returns true on success</td><td>ExportImageAsCode</td><td>bool</td><td><ul><li>image: Image*</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_GenImageColor</b></td><td>Generate image: plain color</td><td>GenImageColor</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_GenImageGradientLinear</b></td><td>Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient</td><td>GenImageGradientLinear</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>direction: int</li>
<li>start: Color*</li>
<li>end: Color*</li></ul></td></tr>
<tr><td><b>wrapped_GenImageGradientRadial</b></td><td>Generate image: radial gradient</td><td>GenImageGradientRadial</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>density: float</li>
<li>inner: Color*</li>
<li>outer: Color*</li></ul></td></tr>
<tr><td><b>wrapped_GenImageGradientSquare</b></td><td>Generate image: square gradient</td><td>GenImageGradientSquare</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>density: float</li>
<li>inner: Color*</li>
<li>outer: Color*</li></ul></td></tr>
<tr><td><b>wrapped_GenImageChecked</b></td><td>Generate image: checked</td><td>GenImageChecked</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>checksX: int</li>
<li>checksY: int</li>
<li>col1: Color*</li>
<li>col2: Color*</li></ul></td></tr>
<tr><td><b>wrapped_GenImageWhiteNoise</b></td><td>Generate image: white noise</td><td>GenImageWhiteNoise</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>factor: float</li></ul></td></tr>
<tr><td><b>wrapped_GenImagePerlinNoise</b></td><td>Generate image: perlin noise</td><td>GenImagePerlinNoise</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>offsetX: int</li>
<li>offsetY: int</li>
<li>scale: float</li></ul></td></tr>
<tr><td><b>wrapped_GenImageCellular</b></td><td>Generate image: cellular algorithm, bigger tileSize means bigger cells</td><td>GenImageCellular</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>tileSize: int</li></ul></td></tr>
<tr><td><b>wrapped_GenImageText</b></td><td>Generate image: grayscale image from text data</td><td>GenImageText</td><td>Image*</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>text: const char *</li></ul></td></tr>
<tr><td><b>wrapped_ImageCopy</b></td><td>Create an image duplicate (useful for transformations)</td><td>ImageCopy</td><td>Image*</td><td><ul><li>image: Image*</li></ul></td></tr>
<tr><td><b>wrapped_ImageFromImage</b></td><td>Create an image from another image piece</td><td>ImageFromImage</td><td>Image*</td><td><ul><li>image: Image*</li>
<li>rec: Rectangle*</li></ul></td></tr>
<tr><td><b>wrapped_ImageText</b></td><td>Create an image from text (default font)</td><td>ImageText</td><td>Image*</td><td><ul><li>text: const char *</li>
<li>fontSize: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageTextEx</b></td><td>Create an image from text (custom sprite font)</td><td>ImageTextEx</td><td>Image*</td><td><ul><li>font: Font*</li>
<li>text: const char *</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageFormat</b></td><td>Convert image data to desired format</td><td>ImageFormat</td><td>void</td><td><ul><li>image: Image **</li>
<li>newFormat: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageToPOT</b></td><td>Convert image to POT (power-of-two)</td><td>ImageToPOT</td><td>void</td><td><ul><li>image: Image **</li>
<li>fill: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageCrop</b></td><td>Crop an image to a defined rectangle</td><td>ImageCrop</td><td>void</td><td><ul><li>image: Image **</li>
<li>crop: Rectangle*</li></ul></td></tr>
<tr><td><b>wrapped_ImageAlphaCrop</b></td><td>Crop image depending on alpha value</td><td>ImageAlphaCrop</td><td>void</td><td><ul><li>image: Image **</li>
<li>threshold: float</li></ul></td></tr>
<tr><td><b>wrapped_ImageAlphaClear</b></td><td>Clear alpha channel to desired color</td><td>ImageAlphaClear</td><td>void</td><td><ul><li>image: Image **</li>
<li>color: Color*</li>
<li>threshold: float</li></ul></td></tr>
<tr><td><b>wrapped_ImageAlphaMask</b></td><td>Apply alpha mask to image</td><td>ImageAlphaMask</td><td>void</td><td><ul><li>image: Image **</li>
<li>alphaMask: Image*</li></ul></td></tr>
<tr><td><b>wrapped_ImageAlphaPremultiply</b></td><td>Premultiply alpha channel</td><td>ImageAlphaPremultiply</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageBlurGaussian</b></td><td>Apply Gaussian blur using a box blur approximation</td><td>ImageBlurGaussian</td><td>void</td><td><ul><li>image: Image **</li>
<li>blurSize: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageResize</b></td><td>Resize image (Bicubic scaling algorithm)</td><td>ImageResize</td><td>void</td><td><ul><li>image: Image **</li>
<li>newWidth: int</li>
<li>newHeight: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageResizeNN</b></td><td>Resize image (Nearest-Neighbor scaling algorithm)</td><td>ImageResizeNN</td><td>void</td><td><ul><li>image: Image **</li>
<li>newWidth: int</li>
<li>newHeight: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageResizeCanvas</b></td><td>Resize canvas and fill with color</td><td>ImageResizeCanvas</td><td>void</td><td><ul><li>image: Image **</li>
<li>newWidth: int</li>
<li>newHeight: int</li>
<li>offsetX: int</li>
<li>offsetY: int</li>
<li>fill: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageMipmaps</b></td><td>Compute all mipmap levels for a provided image</td><td>ImageMipmaps</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageDither</b></td><td>Dither image data to 16bpp or lower (Floyd-Steinberg dithering)</td><td>ImageDither</td><td>void</td><td><ul><li>image: Image **</li>
<li>rBpp: int</li>
<li>gBpp: int</li>
<li>bBpp: int</li>
<li>aBpp: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageFlipVertical</b></td><td>Flip image vertically</td><td>ImageFlipVertical</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageFlipHorizontal</b></td><td>Flip image horizontally</td><td>ImageFlipHorizontal</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageRotate</b></td><td>Rotate image by input angle in degrees (-359 to 359)</td><td>ImageRotate</td><td>void</td><td><ul><li>image: Image **</li>
<li>degrees: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageRotateCW</b></td><td>Rotate image clockwise 90deg</td><td>ImageRotateCW</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageRotateCCW</b></td><td>Rotate image counter-clockwise 90deg</td><td>ImageRotateCCW</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageColorTint</b></td><td>Modify image color: tint</td><td>ImageColorTint</td><td>void</td><td><ul><li>image: Image **</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageColorInvert</b></td><td>Modify image color: invert</td><td>ImageColorInvert</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageColorGrayscale</b></td><td>Modify image color: grayscale</td><td>ImageColorGrayscale</td><td>void</td><td><ul><li>image: Image **</li></ul></td></tr>
<tr><td><b>wrapped_ImageColorContrast</b></td><td>Modify image color: contrast (-100 to 100)</td><td>ImageColorContrast</td><td>void</td><td><ul><li>image: Image **</li>
<li>contrast: float</li></ul></td></tr>
<tr><td><b>wrapped_ImageColorBrightness</b></td><td>Modify image color: brightness (-255 to 255)</td><td>ImageColorBrightness</td><td>void</td><td><ul><li>image: Image **</li>
<li>brightness: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageColorReplace</b></td><td>Modify image color: replace color</td><td>ImageColorReplace</td><td>void</td><td><ul><li>image: Image **</li>
<li>color: Color*</li>
<li>replace: Color*</li></ul></td></tr>
<tr><td><b>wrapped_LoadImageColors</b></td><td>Load color data from image as a Color array (RGBA - 32bit)</td><td>LoadImageColors</td><td>Color **</td><td><ul><li>image: Image*</li></ul></td></tr>
<tr><td><b>wrapped_LoadImagePalette</b></td><td>Load colors palette from image as a Color array (RGBA - 32bit)</td><td>LoadImagePalette</td><td>Color **</td><td><ul><li>image: Image*</li>
<li>maxPaletteSize: int</li>
<li>colorCount: int *</li></ul></td></tr>
<tr><td><b>wrapped_UnloadImageColors</b></td><td>Unload color data loaded with LoadImageColors()</td><td>UnloadImageColors</td><td>void</td><td><ul><li>colors: Color **</li></ul></td></tr>
<tr><td><b>wrapped_UnloadImagePalette</b></td><td>Unload colors palette loaded with LoadImagePalette()</td><td>UnloadImagePalette</td><td>void</td><td><ul><li>colors: Color **</li></ul></td></tr>
<tr><td><b>wrapped_GetImageAlphaBorder</b></td><td>Get image alpha border rectangle</td><td>GetImageAlphaBorder</td><td>Rectangle*</td><td><ul><li>image: Image*</li>
<li>threshold: float</li></ul></td></tr>
<tr><td><b>wrapped_GetImageColor</b></td><td>Get image pixel color at (x, y) position</td><td>GetImageColor</td><td>Color*</td><td><ul><li>image: Image*</li>
<li>x: int</li>
<li>y: int</li></ul></td></tr>
<tr><td><b>wrapped_ImageClearBackground</b></td><td>Clear image background with given color</td><td>ImageClearBackground</td><td>void</td><td><ul><li>dst: Image **</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawPixel</b></td><td>Draw pixel within an image</td><td>ImageDrawPixel</td><td>void</td><td><ul><li>dst: Image **</li>
<li>posX: int</li>
<li>posY: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawPixelV</b></td><td>Draw pixel within an image (Vector version)</td><td>ImageDrawPixelV</td><td>void</td><td><ul><li>dst: Image **</li>
<li>position: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawLine</b></td><td>Draw line within an image</td><td>ImageDrawLine</td><td>void</td><td><ul><li>dst: Image **</li>
<li>startPosX: int</li>
<li>startPosY: int</li>
<li>endPosX: int</li>
<li>endPosY: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawLineV</b></td><td>Draw line within an image (Vector version)</td><td>ImageDrawLineV</td><td>void</td><td><ul><li>dst: Image **</li>
<li>start: Vector2*</li>
<li>end: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawCircle</b></td><td>Draw a filled circle within an image</td><td>ImageDrawCircle</td><td>void</td><td><ul><li>dst: Image **</li>
<li>centerX: int</li>
<li>centerY: int</li>
<li>radius: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawCircleV</b></td><td>Draw a filled circle within an image (Vector version)</td><td>ImageDrawCircleV</td><td>void</td><td><ul><li>dst: Image **</li>
<li>center: Vector2*</li>
<li>radius: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawCircleLines</b></td><td>Draw circle outline within an image</td><td>ImageDrawCircleLines</td><td>void</td><td><ul><li>dst: Image **</li>
<li>centerX: int</li>
<li>centerY: int</li>
<li>radius: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawCircleLinesV</b></td><td>Draw circle outline within an image (Vector version)</td><td>ImageDrawCircleLinesV</td><td>void</td><td><ul><li>dst: Image **</li>
<li>center: Vector2*</li>
<li>radius: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawRectangle</b></td><td>Draw rectangle within an image</td><td>ImageDrawRectangle</td><td>void</td><td><ul><li>dst: Image **</li>
<li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawRectangleV</b></td><td>Draw rectangle within an image (Vector version)</td><td>ImageDrawRectangleV</td><td>void</td><td><ul><li>dst: Image **</li>
<li>position: Vector2*</li>
<li>size: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawRectangleRec</b></td><td>Draw rectangle within an image</td><td>ImageDrawRectangleRec</td><td>void</td><td><ul><li>dst: Image **</li>
<li>rec: Rectangle*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawRectangleLines</b></td><td>Draw rectangle lines within an image</td><td>ImageDrawRectangleLines</td><td>void</td><td><ul><li>dst: Image **</li>
<li>rec: Rectangle*</li>
<li>thick: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDraw</b></td><td>Draw a source image within a destination image (tint applied to source)</td><td>ImageDraw</td><td>void</td><td><ul><li>dst: Image **</li>
<li>src: Image*</li>
<li>srcRec: Rectangle*</li>
<li>dstRec: Rectangle*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawText</b></td><td>Draw text (using default font) within an image (destination)</td><td>ImageDrawText</td><td>void</td><td><ul><li>dst: Image **</li>
<li>text: const char *</li>
<li>posX: int</li>
<li>posY: int</li>
<li>fontSize: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ImageDrawTextEx</b></td><td>Draw text (custom sprite font) within an image (destination)</td><td>ImageDrawTextEx</td><td>void</td><td><ul><li>dst: Image **</li>
<li>font: Font*</li>
<li>text: const char *</li>
<li>position: Vector2*</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_LoadTexture</b></td><td>Load texture from file into GPU memory (VRAM)</td><td>LoadTexture</td><td>Texture2D*</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadTextureFromImage</b></td><td>Load texture from image data</td><td>LoadTextureFromImage</td><td>Texture2D*</td><td><ul><li>image: Image*</li></ul></td></tr>
<tr><td><b>wrapped_LoadTextureCubemap</b></td><td>Load cubemap from image, multiple image cubemap layouts supported</td><td>LoadTextureCubemap</td><td>TextureCubemap*</td><td><ul><li>image: Image*</li>
<li>layout: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadRenderTexture</b></td><td>Load texture for rendering (framebuffer)</td><td>LoadRenderTexture</td><td>RenderTexture2D*</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>wrapped_IsTextureReady</b></td><td>Check if a texture is ready</td><td>IsTextureReady</td><td>bool</td><td><ul><li>texture: Texture2D*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadTexture</b></td><td>Unload texture from GPU memory (VRAM)</td><td>UnloadTexture</td><td>void</td><td><ul><li>texture: Texture2D*</li></ul></td></tr>
<tr><td><b>wrapped_IsRenderTextureReady</b></td><td>Check if a render texture is ready</td><td>IsRenderTextureReady</td><td>bool</td><td><ul><li>target: RenderTexture2D*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadRenderTexture</b></td><td>Unload render texture from GPU memory (VRAM)</td><td>UnloadRenderTexture</td><td>void</td><td><ul><li>target: RenderTexture2D*</li></ul></td></tr>
<tr><td><b>wrapped_UpdateTexture</b></td><td>Update GPU texture with new data</td><td>UpdateTexture</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>pixels: const void *</li></ul></td></tr>
<tr><td><b>wrapped_UpdateTextureRec</b></td><td>Update GPU texture rectangle with new data</td><td>UpdateTextureRec</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>rec: Rectangle*</li>
<li>pixels: const void *</li></ul></td></tr>
<tr><td><b>wrapped_GenTextureMipmaps</b></td><td>Generate GPU mipmaps for a texture</td><td>GenTextureMipmaps</td><td>void</td><td><ul><li>texture: Texture2D **</li></ul></td></tr>
<tr><td><b>wrapped_SetTextureFilter</b></td><td>Set texture scaling filter mode</td><td>SetTextureFilter</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>filter: int</li></ul></td></tr>
<tr><td><b>wrapped_SetTextureWrap</b></td><td>Set texture wrapping mode</td><td>SetTextureWrap</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>wrap: int</li></ul></td></tr>
<tr><td><b>wrapped_DrawTexture</b></td><td>Draw a Texture2D</td><td>DrawTexture</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>posX: int</li>
<li>posY: int</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextureV</b></td><td>Draw a Texture2D with position defined as Vector2</td><td>DrawTextureV</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>position: Vector2*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextureEx</b></td><td>Draw a Texture2D with extended parameters</td><td>DrawTextureEx</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>position: Vector2*</li>
<li>rotation: float</li>
<li>scale: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextureRec</b></td><td>Draw a part of a texture defined by a rectangle</td><td>DrawTextureRec</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>source: Rectangle*</li>
<li>position: Vector2*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTexturePro</b></td><td>Draw a part of a texture defined by a rectangle with 'pro' parameters</td><td>DrawTexturePro</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>source: Rectangle*</li>
<li>dest: Rectangle*</li>
<li>origin: Vector2*</li>
<li>rotation: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextureNPatch</b></td><td>Draws a texture (or part of it) that stretches or shrinks nicely</td><td>DrawTextureNPatch</td><td>void</td><td><ul><li>texture: Texture2D*</li>
<li>nPatchInfo: NPatchInfo*</li>
<li>dest: Rectangle*</li>
<li>origin: Vector2*</li>
<li>rotation: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_Fade</b></td><td>Get color with alpha applied, alpha goes from 0.0f to 1.0f</td><td>Fade</td><td>Color*</td><td><ul><li>color: Color*</li>
<li>alpha: float</li></ul></td></tr>
<tr><td><b>wrapped_ColorToInt</b></td><td>Get hexadecimal value for a Color</td><td>ColorToInt</td><td>int</td><td><ul><li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ColorNormalize</b></td><td>Get Color normalized as float [0..1]</td><td>ColorNormalize</td><td>Vector4*</td><td><ul><li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ColorFromNormalized</b></td><td>Get Color from normalized values [0..1]</td><td>ColorFromNormalized</td><td>Color*</td><td><ul><li>normalized: Vector4*</li></ul></td></tr>
<tr><td><b>wrapped_ColorToHSV</b></td><td>Get HSV values for a Color, hue [0..360], saturation/value [0..1]</td><td>ColorToHSV</td><td>Vector3*</td><td><ul><li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ColorFromHSV</b></td><td>Get a Color from HSV values, hue [0..360], saturation/value [0..1]</td><td>ColorFromHSV</td><td>Color*</td><td><ul><li>hue: float</li>
<li>saturation: float</li>
<li>value: float</li></ul></td></tr>
<tr><td><b>wrapped_ColorTint</b></td><td>Get color multiplied with another color</td><td>ColorTint</td><td>Color*</td><td><ul><li>color: Color*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_ColorBrightness</b></td><td>Get color with brightness correction, brightness factor goes from -1.0f to 1.0f</td><td>ColorBrightness</td><td>Color*</td><td><ul><li>color: Color*</li>
<li>factor: float</li></ul></td></tr>
<tr><td><b>wrapped_ColorContrast</b></td><td>Get color with contrast correction, contrast values between -1.0f and 1.0f</td><td>ColorContrast</td><td>Color*</td><td><ul><li>color: Color*</li>
<li>contrast: float</li></ul></td></tr>
<tr><td><b>wrapped_ColorAlpha</b></td><td>Get color with alpha applied, alpha goes from 0.0f to 1.0f</td><td>ColorAlpha</td><td>Color*</td><td><ul><li>color: Color*</li>
<li>alpha: float</li></ul></td></tr>
<tr><td><b>wrapped_ColorAlphaBlend</b></td><td>Get src alpha-blended into dst color with tint</td><td>ColorAlphaBlend</td><td>Color*</td><td><ul><li>dst: Color*</li>
<li>src: Color*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_GetColor</b></td><td>Get Color structure from hexadecimal value</td><td>GetColor</td><td>Color*</td><td><ul><li>hexValue: unsigned int</li></ul></td></tr>
<tr><td><b>wrapped_GetPixelColor</b></td><td>Get Color from a source pixel pointer of certain format</td><td>GetPixelColor</td><td>Color*</td><td><ul><li>srcPtr: void *</li>
<li>format: int</li></ul></td></tr>
<tr><td><b>wrapped_SetPixelColor</b></td><td>Set color formatted into destination pixel pointer</td><td>SetPixelColor</td><td>void</td><td><ul><li>dstPtr: void *</li>
<li>color: Color*</li>
<li>format: int</li></ul></td></tr>
<tr><td><b>wrapped_GetFontDefault</b></td><td>Get the default Font</td><td>GetFontDefault</td><td>Font*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_LoadFont</b></td><td>Load font from file into GPU memory (VRAM)</td><td>LoadFont</td><td>Font*</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadFontEx</b></td><td>Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character setFont</td><td>LoadFontEx</td><td>Font*</td><td><ul><li>fileName: const char *</li>
<li>fontSize: int</li>
<li>codepoints: int *</li>
<li>codepointCount: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadFontFromImage</b></td><td>Load font from Image (XNA style)</td><td>LoadFontFromImage</td><td>Font*</td><td><ul><li>image: Image*</li>
<li>key: Color*</li>
<li>firstChar: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadFontFromMemory</b></td><td>Load font from memory buffer, fileType refers to extension: i.e. '.ttf'</td><td>LoadFontFromMemory</td><td>Font*</td><td><ul><li>fileType: const char *</li>
<li>fileData: const unsigned char *</li>
<li>dataSize: int</li>
<li>fontSize: int</li>
<li>codepoints: int *</li>
<li>codepointCount: int</li></ul></td></tr>
<tr><td><b>wrapped_IsFontReady</b></td><td>Check if a font is ready</td><td>IsFontReady</td><td>bool</td><td><ul><li>font: Font*</li></ul></td></tr>
<tr><td><b>wrapped_LoadFontData</b></td><td>Load font data for further use</td><td>LoadFontData</td><td>GlyphInfo **</td><td><ul><li>fileData: const unsigned char *</li>
<li>dataSize: int</li>
<li>fontSize: int</li>
<li>codepoints: int *</li>
<li>codepointCount: int</li>
<li>type: int</li></ul></td></tr>
<tr><td><b>wrapped_GenImageFontAtlas</b></td><td>Generate image font atlas using chars info</td><td>GenImageFontAtlas</td><td>Image*</td><td><ul><li>glyphs: const GlyphInfo **</li>
<li>glyphRecs: Rectangle ***</li>
<li>glyphCount: int</li>
<li>fontSize: int</li>
<li>padding: int</li>
<li>packMethod: int</li></ul></td></tr>
<tr><td><b>wrapped_UnloadFontData</b></td><td>Unload font chars info data (RAM)</td><td>UnloadFontData</td><td>void</td><td><ul><li>glyphs: GlyphInfo **</li>
<li>glyphCount: int</li></ul></td></tr>
<tr><td><b>wrapped_UnloadFont</b></td><td>Unload font from GPU memory (VRAM)</td><td>UnloadFont</td><td>void</td><td><ul><li>font: Font*</li></ul></td></tr>
<tr><td><b>wrapped_ExportFontAsCode</b></td><td>Export font as code file, returns true on success</td><td>ExportFontAsCode</td><td>bool</td><td><ul><li>font: Font*</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_DrawText</b></td><td>Draw text (using default font)</td><td>DrawText</td><td>void</td><td><ul><li>text: const char *</li>
<li>posX: int</li>
<li>posY: int</li>
<li>fontSize: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextEx</b></td><td>Draw text using font and additional parameters</td><td>DrawTextEx</td><td>void</td><td><ul><li>font: Font*</li>
<li>text: const char *</li>
<li>position: Vector2*</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextPro</b></td><td>Draw text using Font and pro parameters (rotation)</td><td>DrawTextPro</td><td>void</td><td><ul><li>font: Font*</li>
<li>text: const char *</li>
<li>position: Vector2*</li>
<li>origin: Vector2*</li>
<li>rotation: float</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextCodepoint</b></td><td>Draw one character (codepoint)</td><td>DrawTextCodepoint</td><td>void</td><td><ul><li>font: Font*</li>
<li>codepoint: int</li>
<li>position: Vector2*</li>
<li>fontSize: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTextCodepoints</b></td><td>Draw multiple character (codepoint)</td><td>DrawTextCodepoints</td><td>void</td><td><ul><li>font: Font*</li>
<li>codepoints: const int *</li>
<li>codepointCount: int</li>
<li>position: Vector2*</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_MeasureTextEx</b></td><td>Measure string size for Font</td><td>MeasureTextEx</td><td>Vector2*</td><td><ul><li>font: Font*</li>
<li>text: const char *</li>
<li>fontSize: float</li>
<li>spacing: float</li></ul></td></tr>
<tr><td><b>wrapped_GetGlyphIndex</b></td><td>Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found</td><td>GetGlyphIndex</td><td>int</td><td><ul><li>font: Font*</li>
<li>codepoint: int</li></ul></td></tr>
<tr><td><b>wrapped_GetGlyphInfo</b></td><td>Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found</td><td>GetGlyphInfo</td><td>GlyphInfo*</td><td><ul><li>font: Font*</li>
<li>codepoint: int</li></ul></td></tr>
<tr><td><b>wrapped_GetGlyphAtlasRec</b></td><td>Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found</td><td>GetGlyphAtlasRec</td><td>Rectangle*</td><td><ul><li>font: Font*</li>
<li>codepoint: int</li></ul></td></tr>
<tr><td><b>wrapped_DrawLine3D</b></td><td>Draw a line in 3D world space</td><td>DrawLine3D</td><td>void</td><td><ul><li>startPos: Vector3*</li>
<li>endPos: Vector3*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawPoint3D</b></td><td>Draw a point in 3D space, actually a small line</td><td>DrawPoint3D</td><td>void</td><td><ul><li>position: Vector3*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCircle3D</b></td><td>Draw a circle in 3D world space</td><td>DrawCircle3D</td><td>void</td><td><ul><li>center: Vector3*</li>
<li>radius: float</li>
<li>rotationAxis: Vector3*</li>
<li>rotationAngle: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTriangle3D</b></td><td>Draw a color-filled triangle (vertex in counter-clockwise order!)</td><td>DrawTriangle3D</td><td>void</td><td><ul><li>v1: Vector3*</li>
<li>v2: Vector3*</li>
<li>v3: Vector3*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawTriangleStrip3D</b></td><td>Draw a triangle strip defined by points</td><td>DrawTriangleStrip3D</td><td>void</td><td><ul><li>points: Vector3 **</li>
<li>pointCount: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCube</b></td><td>Draw cube</td><td>DrawCube</td><td>void</td><td><ul><li>position: Vector3*</li>
<li>width: float</li>
<li>height: float</li>
<li>length: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCubeV</b></td><td>Draw cube (Vector version)</td><td>DrawCubeV</td><td>void</td><td><ul><li>position: Vector3*</li>
<li>size: Vector3*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCubeWires</b></td><td>Draw cube wires</td><td>DrawCubeWires</td><td>void</td><td><ul><li>position: Vector3*</li>
<li>width: float</li>
<li>height: float</li>
<li>length: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCubeWiresV</b></td><td>Draw cube wires (Vector version)</td><td>DrawCubeWiresV</td><td>void</td><td><ul><li>position: Vector3*</li>
<li>size: Vector3*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawSphere</b></td><td>Draw sphere</td><td>DrawSphere</td><td>void</td><td><ul><li>centerPos: Vector3*</li>
<li>radius: float</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawSphereEx</b></td><td>Draw sphere with extended parameters</td><td>DrawSphereEx</td><td>void</td><td><ul><li>centerPos: Vector3*</li>
<li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawSphereWires</b></td><td>Draw sphere wires</td><td>DrawSphereWires</td><td>void</td><td><ul><li>centerPos: Vector3*</li>
<li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCylinder</b></td><td>Draw a cylinder/cone</td><td>DrawCylinder</td><td>void</td><td><ul><li>position: Vector3*</li>
<li>radiusTop: float</li>
<li>radiusBottom: float</li>
<li>height: float</li>
<li>slices: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCylinderEx</b></td><td>Draw a cylinder with base at startPos and top at endPos</td><td>DrawCylinderEx</td><td>void</td><td><ul><li>startPos: Vector3*</li>
<li>endPos: Vector3*</li>
<li>startRadius: float</li>
<li>endRadius: float</li>
<li>sides: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCylinderWires</b></td><td>Draw a cylinder/cone wires</td><td>DrawCylinderWires</td><td>void</td><td><ul><li>position: Vector3*</li>
<li>radiusTop: float</li>
<li>radiusBottom: float</li>
<li>height: float</li>
<li>slices: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCylinderWiresEx</b></td><td>Draw a cylinder wires with base at startPos and top at endPos</td><td>DrawCylinderWiresEx</td><td>void</td><td><ul><li>startPos: Vector3*</li>
<li>endPos: Vector3*</li>
<li>startRadius: float</li>
<li>endRadius: float</li>
<li>sides: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCapsule</b></td><td>Draw a capsule with the center of its sphere caps at startPos and endPos</td><td>DrawCapsule</td><td>void</td><td><ul><li>startPos: Vector3*</li>
<li>endPos: Vector3*</li>
<li>radius: float</li>
<li>slices: int</li>
<li>rings: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawCapsuleWires</b></td><td>Draw capsule wireframe with the center of its sphere caps at startPos and endPos</td><td>DrawCapsuleWires</td><td>void</td><td><ul><li>startPos: Vector3*</li>
<li>endPos: Vector3*</li>
<li>radius: float</li>
<li>slices: int</li>
<li>rings: int</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawPlane</b></td><td>Draw a plane XZ</td><td>DrawPlane</td><td>void</td><td><ul><li>centerPos: Vector3*</li>
<li>size: Vector2*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawRay</b></td><td>Draw a ray line</td><td>DrawRay</td><td>void</td><td><ul><li>ray: Ray*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_LoadModel</b></td><td>Load model from files (meshes and materials)</td><td>LoadModel</td><td>Model*</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadModelFromMesh</b></td><td>Load model from generated mesh (default material)</td><td>LoadModelFromMesh</td><td>Model*</td><td><ul><li>mesh: Mesh*</li></ul></td></tr>
<tr><td><b>wrapped_IsModelReady</b></td><td>Check if a model is ready</td><td>IsModelReady</td><td>bool</td><td><ul><li>model: Model*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadModel</b></td><td>Unload model (including meshes) from memory (RAM and/or VRAM)</td><td>UnloadModel</td><td>void</td><td><ul><li>model: Model*</li></ul></td></tr>
<tr><td><b>wrapped_GetModelBoundingBox</b></td><td>Compute model bounding box limits (considers all meshes)</td><td>GetModelBoundingBox</td><td>BoundingBox*</td><td><ul><li>model: Model*</li></ul></td></tr>
<tr><td><b>wrapped_DrawModel</b></td><td>Draw a model (with texture if set)</td><td>DrawModel</td><td>void</td><td><ul><li>model: Model*</li>
<li>position: Vector3*</li>
<li>scale: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawModelEx</b></td><td>Draw a model with extended parameters</td><td>DrawModelEx</td><td>void</td><td><ul><li>model: Model*</li>
<li>position: Vector3*</li>
<li>rotationAxis: Vector3*</li>
<li>rotationAngle: float</li>
<li>scale: Vector3*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawModelWires</b></td><td>Draw a model wires (with texture if set)</td><td>DrawModelWires</td><td>void</td><td><ul><li>model: Model*</li>
<li>position: Vector3*</li>
<li>scale: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawModelWiresEx</b></td><td>Draw a model wires (with texture if set) with extended parameters</td><td>DrawModelWiresEx</td><td>void</td><td><ul><li>model: Model*</li>
<li>position: Vector3*</li>
<li>rotationAxis: Vector3*</li>
<li>rotationAngle: float</li>
<li>scale: Vector3*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawBoundingBox</b></td><td>Draw bounding box (wires)</td><td>DrawBoundingBox</td><td>void</td><td><ul><li>box: BoundingBox*</li>
<li>color: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawBillboard</b></td><td>Draw a billboard texture</td><td>DrawBillboard</td><td>void</td><td><ul><li>camera: Camera*</li>
<li>texture: Texture2D*</li>
<li>position: Vector3*</li>
<li>size: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawBillboardRec</b></td><td>Draw a billboard texture defined by source</td><td>DrawBillboardRec</td><td>void</td><td><ul><li>camera: Camera*</li>
<li>texture: Texture2D*</li>
<li>source: Rectangle*</li>
<li>position: Vector3*</li>
<li>size: Vector2*</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_DrawBillboardPro</b></td><td>Draw a billboard texture defined by source and rotation</td><td>DrawBillboardPro</td><td>void</td><td><ul><li>camera: Camera*</li>
<li>texture: Texture2D*</li>
<li>source: Rectangle*</li>
<li>position: Vector3*</li>
<li>up: Vector3*</li>
<li>size: Vector2*</li>
<li>origin: Vector2*</li>
<li>rotation: float</li>
<li>tint: Color*</li></ul></td></tr>
<tr><td><b>wrapped_UploadMesh</b></td><td>Upload mesh vertex data in GPU and provide VAO/VBO ids</td><td>UploadMesh</td><td>void</td><td><ul><li>mesh: Mesh **</li>
<li>dynamic: bool</li></ul></td></tr>
<tr><td><b>wrapped_UpdateMeshBuffer</b></td><td>Update mesh vertex data in GPU for a specific buffer index</td><td>UpdateMeshBuffer</td><td>void</td><td><ul><li>mesh: Mesh*</li>
<li>index: int</li>
<li>data: const void *</li>
<li>dataSize: int</li>
<li>offset: int</li></ul></td></tr>
<tr><td><b>wrapped_UnloadMesh</b></td><td>Unload mesh data from CPU and GPU</td><td>UnloadMesh</td><td>void</td><td><ul><li>mesh: Mesh*</li></ul></td></tr>
<tr><td><b>wrapped_DrawMesh</b></td><td>Draw a 3d mesh with material and transform</td><td>DrawMesh</td><td>void</td><td><ul><li>mesh: Mesh*</li>
<li>material: Material*</li>
<li>transform: Matrix*</li></ul></td></tr>
<tr><td><b>wrapped_DrawMeshInstanced</b></td><td>Draw multiple mesh instances with material and different transforms</td><td>DrawMeshInstanced</td><td>void</td><td><ul><li>mesh: Mesh*</li>
<li>material: Material*</li>
<li>transforms: const Matrix **</li>
<li>instances: int</li></ul></td></tr>
<tr><td><b>wrapped_ExportMesh</b></td><td>Export mesh data to file, returns true on success</td><td>ExportMesh</td><td>bool</td><td><ul><li>mesh: Mesh*</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_GetMeshBoundingBox</b></td><td>Compute mesh bounding box limits</td><td>GetMeshBoundingBox</td><td>BoundingBox*</td><td><ul><li>mesh: Mesh*</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshTangents</b></td><td>Compute mesh tangents</td><td>GenMeshTangents</td><td>void</td><td><ul><li>mesh: Mesh **</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshPoly</b></td><td>Generate polygonal mesh</td><td>GenMeshPoly</td><td>Mesh*</td><td><ul><li>sides: int</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshPlane</b></td><td>Generate plane mesh (with subdivisions)</td><td>GenMeshPlane</td><td>Mesh*</td><td><ul><li>width: float</li>
<li>length: float</li>
<li>resX: int</li>
<li>resZ: int</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshCube</b></td><td>Generate cuboid mesh</td><td>GenMeshCube</td><td>Mesh*</td><td><ul><li>width: float</li>
<li>height: float</li>
<li>length: float</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshSphere</b></td><td>Generate sphere mesh (standard sphere)</td><td>GenMeshSphere</td><td>Mesh*</td><td><ul><li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshHemiSphere</b></td><td>Generate half-sphere mesh (no bottom cap)</td><td>GenMeshHemiSphere</td><td>Mesh*</td><td><ul><li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshCylinder</b></td><td>Generate cylinder mesh</td><td>GenMeshCylinder</td><td>Mesh*</td><td><ul><li>radius: float</li>
<li>height: float</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshCone</b></td><td>Generate cone/pyramid mesh</td><td>GenMeshCone</td><td>Mesh*</td><td><ul><li>radius: float</li>
<li>height: float</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshTorus</b></td><td>Generate torus mesh</td><td>GenMeshTorus</td><td>Mesh*</td><td><ul><li>radius: float</li>
<li>size: float</li>
<li>radSeg: int</li>
<li>sides: int</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshKnot</b></td><td>Generate trefoil knot mesh</td><td>GenMeshKnot</td><td>Mesh*</td><td><ul><li>radius: float</li>
<li>size: float</li>
<li>radSeg: int</li>
<li>sides: int</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshHeightmap</b></td><td>Generate heightmap mesh from image data</td><td>GenMeshHeightmap</td><td>Mesh*</td><td><ul><li>heightmap: Image*</li>
<li>size: Vector3*</li></ul></td></tr>
<tr><td><b>wrapped_GenMeshCubicmap</b></td><td>Generate cubes-based map mesh from image data</td><td>GenMeshCubicmap</td><td>Mesh*</td><td><ul><li>cubicmap: Image*</li>
<li>cubeSize: Vector3*</li></ul></td></tr>
<tr><td><b>wrapped_LoadMaterials</b></td><td>Load materials from model file</td><td>LoadMaterials</td><td>Material **</td><td><ul><li>fileName: const char *</li>
<li>materialCount: int *</li></ul></td></tr>
<tr><td><b>wrapped_LoadMaterialDefault</b></td><td>Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)</td><td>LoadMaterialDefault</td><td>Material*</td><td><ul></ul></td></tr>
<tr><td><b>wrapped_IsMaterialReady</b></td><td>Check if a material is ready</td><td>IsMaterialReady</td><td>bool</td><td><ul><li>material: Material*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadMaterial</b></td><td>Unload material from GPU memory (VRAM)</td><td>UnloadMaterial</td><td>void</td><td><ul><li>material: Material*</li></ul></td></tr>
<tr><td><b>wrapped_SetMaterialTexture</b></td><td>Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)</td><td>SetMaterialTexture</td><td>void</td><td><ul><li>material: Material **</li>
<li>mapType: int</li>
<li>texture: Texture2D*</li></ul></td></tr>
<tr><td><b>wrapped_SetModelMeshMaterial</b></td><td>Set material for a mesh</td><td>SetModelMeshMaterial</td><td>void</td><td><ul><li>model: Model **</li>
<li>meshId: int</li>
<li>materialId: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadModelAnimations</b></td><td>Load model animations from file</td><td>LoadModelAnimations</td><td>ModelAnimation **</td><td><ul><li>fileName: const char *</li>
<li>animCount: int *</li></ul></td></tr>
<tr><td><b>wrapped_UpdateModelAnimation</b></td><td>Update model animation pose</td><td>UpdateModelAnimation</td><td>void</td><td><ul><li>model: Model*</li>
<li>anim: ModelAnimation*</li>
<li>frame: int</li></ul></td></tr>
<tr><td><b>wrapped_UnloadModelAnimation</b></td><td>Unload animation data</td><td>UnloadModelAnimation</td><td>void</td><td><ul><li>anim: ModelAnimation*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadModelAnimations</b></td><td>Unload animation array data</td><td>UnloadModelAnimations</td><td>void</td><td><ul><li>animations: ModelAnimation **</li>
<li>animCount: int</li></ul></td></tr>
<tr><td><b>wrapped_IsModelAnimationValid</b></td><td>Check model animation skeleton match</td><td>IsModelAnimationValid</td><td>bool</td><td><ul><li>model: Model*</li>
<li>anim: ModelAnimation*</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionSpheres</b></td><td>Check collision between two spheres</td><td>CheckCollisionSpheres</td><td>bool</td><td><ul><li>center1: Vector3*</li>
<li>radius1: float</li>
<li>center2: Vector3*</li>
<li>radius2: float</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionBoxes</b></td><td>Check collision between two bounding boxes</td><td>CheckCollisionBoxes</td><td>bool</td><td><ul><li>box1: BoundingBox*</li>
<li>box2: BoundingBox*</li></ul></td></tr>
<tr><td><b>wrapped_CheckCollisionBoxSphere</b></td><td>Check collision between box and sphere</td><td>CheckCollisionBoxSphere</td><td>bool</td><td><ul><li>box: BoundingBox*</li>
<li>center: Vector3*</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>wrapped_GetRayCollisionSphere</b></td><td>Get collision info between ray and sphere</td><td>GetRayCollisionSphere</td><td>RayCollision*</td><td><ul><li>ray: Ray*</li>
<li>center: Vector3*</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>wrapped_GetRayCollisionBox</b></td><td>Get collision info between ray and box</td><td>GetRayCollisionBox</td><td>RayCollision*</td><td><ul><li>ray: Ray*</li>
<li>box: BoundingBox*</li></ul></td></tr>
<tr><td><b>wrapped_GetRayCollisionMesh</b></td><td>Get collision info between ray and mesh</td><td>GetRayCollisionMesh</td><td>RayCollision*</td><td><ul><li>ray: Ray*</li>
<li>mesh: Mesh*</li>
<li>transform: Matrix*</li></ul></td></tr>
<tr><td><b>wrapped_GetRayCollisionTriangle</b></td><td>Get collision info between ray and triangle</td><td>GetRayCollisionTriangle</td><td>RayCollision*</td><td><ul><li>ray: Ray*</li>
<li>p1: Vector3*</li>
<li>p2: Vector3*</li>
<li>p3: Vector3*</li></ul></td></tr>
<tr><td><b>wrapped_GetRayCollisionQuad</b></td><td>Get collision info between ray and quad</td><td>GetRayCollisionQuad</td><td>RayCollision*</td><td><ul><li>ray: Ray*</li>
<li>p1: Vector3*</li>
<li>p2: Vector3*</li>
<li>p3: Vector3*</li>
<li>p4: Vector3*</li></ul></td></tr>
<tr><td><b>wrapped_LoadWave</b></td><td>Load wave data from file</td><td>LoadWave</td><td>Wave*</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadWaveFromMemory</b></td><td>Load wave from memory buffer, fileType refers to extension: i.e. '.wav'</td><td>LoadWaveFromMemory</td><td>Wave*</td><td><ul><li>fileType: const char *</li>
<li>fileData: const unsigned char *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>wrapped_IsWaveReady</b></td><td>Checks if wave data is ready</td><td>IsWaveReady</td><td>bool</td><td><ul><li>wave: Wave*</li></ul></td></tr>
<tr><td><b>wrapped_LoadSound</b></td><td>Load sound from file</td><td>LoadSound</td><td>Sound*</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadSoundFromWave</b></td><td>Load sound from wave data</td><td>LoadSoundFromWave</td><td>Sound*</td><td><ul><li>wave: Wave*</li></ul></td></tr>
<tr><td><b>wrapped_LoadSoundAlias</b></td><td>Create a new sound that shares the same sample data as the source sound, does not own the sound data</td><td>LoadSoundAlias</td><td>Sound*</td><td><ul><li>source: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_IsSoundReady</b></td><td>Checks if a sound is ready</td><td>IsSoundReady</td><td>bool</td><td><ul><li>sound: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_UpdateSound</b></td><td>Update sound buffer with new data</td><td>UpdateSound</td><td>void</td><td><ul><li>sound: Sound*</li>
<li>data: const void *</li>
<li>sampleCount: int</li></ul></td></tr>
<tr><td><b>wrapped_UnloadWave</b></td><td>Unload wave data</td><td>UnloadWave</td><td>void</td><td><ul><li>wave: Wave*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadSound</b></td><td>Unload sound</td><td>UnloadSound</td><td>void</td><td><ul><li>sound: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadSoundAlias</b></td><td>Unload a sound alias (does not deallocate sample data)</td><td>UnloadSoundAlias</td><td>void</td><td><ul><li>alias: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_ExportWave</b></td><td>Export wave data to file, returns true on success</td><td>ExportWave</td><td>bool</td><td><ul><li>wave: Wave*</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_ExportWaveAsCode</b></td><td>Export wave sample data to code (.h), returns true on success</td><td>ExportWaveAsCode</td><td>bool</td><td><ul><li>wave: Wave*</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_PlaySound</b></td><td>Play a sound</td><td>PlaySound</td><td>void</td><td><ul><li>sound: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_StopSound</b></td><td>Stop playing a sound</td><td>StopSound</td><td>void</td><td><ul><li>sound: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_PauseSound</b></td><td>Pause a sound</td><td>PauseSound</td><td>void</td><td><ul><li>sound: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_ResumeSound</b></td><td>Resume a paused sound</td><td>ResumeSound</td><td>void</td><td><ul><li>sound: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_IsSoundPlaying</b></td><td>Check if a sound is currently playing</td><td>IsSoundPlaying</td><td>bool</td><td><ul><li>sound: Sound*</li></ul></td></tr>
<tr><td><b>wrapped_SetSoundVolume</b></td><td>Set volume for a sound (1.0 is max level)</td><td>SetSoundVolume</td><td>void</td><td><ul><li>sound: Sound*</li>
<li>volume: float</li></ul></td></tr>
<tr><td><b>wrapped_SetSoundPitch</b></td><td>Set pitch for a sound (1.0 is base level)</td><td>SetSoundPitch</td><td>void</td><td><ul><li>sound: Sound*</li>
<li>pitch: float</li></ul></td></tr>
<tr><td><b>wrapped_SetSoundPan</b></td><td>Set pan for a sound (0.5 is center)</td><td>SetSoundPan</td><td>void</td><td><ul><li>sound: Sound*</li>
<li>pan: float</li></ul></td></tr>
<tr><td><b>wrapped_WaveCopy</b></td><td>Copy a wave to a new wave</td><td>WaveCopy</td><td>Wave*</td><td><ul><li>wave: Wave*</li></ul></td></tr>
<tr><td><b>wrapped_WaveCrop</b></td><td>Crop a wave to defined samples range</td><td>WaveCrop</td><td>void</td><td><ul><li>wave: Wave **</li>
<li>initSample: int</li>
<li>finalSample: int</li></ul></td></tr>
<tr><td><b>wrapped_WaveFormat</b></td><td>Convert wave data to desired format</td><td>WaveFormat</td><td>void</td><td><ul><li>wave: Wave **</li>
<li>sampleRate: int</li>
<li>sampleSize: int</li>
<li>channels: int</li></ul></td></tr>
<tr><td><b>wrapped_LoadWaveSamples</b></td><td>Load samples data from wave as a 32bit float data array</td><td>LoadWaveSamples</td><td>float *</td><td><ul><li>wave: Wave*</li></ul></td></tr>
<tr><td><b>wrapped_LoadMusicStream</b></td><td>Load music stream from file</td><td>LoadMusicStream</td><td>Music*</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>wrapped_LoadMusicStreamFromMemory</b></td><td>Load music stream from data</td><td>LoadMusicStreamFromMemory</td><td>Music*</td><td><ul><li>fileType: const char *</li>
<li>data: const unsigned char *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>wrapped_IsMusicReady</b></td><td>Checks if a music stream is ready</td><td>IsMusicReady</td><td>bool</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadMusicStream</b></td><td>Unload music stream</td><td>UnloadMusicStream</td><td>void</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_PlayMusicStream</b></td><td>Start music playing</td><td>PlayMusicStream</td><td>void</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_IsMusicStreamPlaying</b></td><td>Check if music is playing</td><td>IsMusicStreamPlaying</td><td>bool</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_UpdateMusicStream</b></td><td>Updates buffers for music streaming</td><td>UpdateMusicStream</td><td>void</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_StopMusicStream</b></td><td>Stop music playing</td><td>StopMusicStream</td><td>void</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_PauseMusicStream</b></td><td>Pause music playing</td><td>PauseMusicStream</td><td>void</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_ResumeMusicStream</b></td><td>Resume playing paused music</td><td>ResumeMusicStream</td><td>void</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_SeekMusicStream</b></td><td>Seek music to a position (in seconds)</td><td>SeekMusicStream</td><td>void</td><td><ul><li>music: Music*</li>
<li>position: float</li></ul></td></tr>
<tr><td><b>wrapped_SetMusicVolume</b></td><td>Set volume for music (1.0 is max level)</td><td>SetMusicVolume</td><td>void</td><td><ul><li>music: Music*</li>
<li>volume: float</li></ul></td></tr>
<tr><td><b>wrapped_SetMusicPitch</b></td><td>Set pitch for a music (1.0 is base level)</td><td>SetMusicPitch</td><td>void</td><td><ul><li>music: Music*</li>
<li>pitch: float</li></ul></td></tr>
<tr><td><b>wrapped_SetMusicPan</b></td><td>Set pan for a music (0.5 is center)</td><td>SetMusicPan</td><td>void</td><td><ul><li>music: Music*</li>
<li>pan: float</li></ul></td></tr>
<tr><td><b>wrapped_GetMusicTimeLength</b></td><td>Get music time length (in seconds)</td><td>GetMusicTimeLength</td><td>float</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_GetMusicTimePlayed</b></td><td>Get current music time played (in seconds)</td><td>GetMusicTimePlayed</td><td>float</td><td><ul><li>music: Music*</li></ul></td></tr>
<tr><td><b>wrapped_LoadAudioStream</b></td><td>Load audio stream (to stream raw audio pcm data)</td><td>LoadAudioStream</td><td>AudioStream*</td><td><ul><li>sampleRate: unsigned int</li>
<li>sampleSize: unsigned int</li>
<li>channels: unsigned int</li></ul></td></tr>
<tr><td><b>wrapped_IsAudioStreamReady</b></td><td>Checks if an audio stream is ready</td><td>IsAudioStreamReady</td><td>bool</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_UnloadAudioStream</b></td><td>Unload audio stream and free memory</td><td>UnloadAudioStream</td><td>void</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_UpdateAudioStream</b></td><td>Update audio stream buffers with data</td><td>UpdateAudioStream</td><td>void</td><td><ul><li>stream: AudioStream*</li>
<li>data: const void *</li>
<li>frameCount: int</li></ul></td></tr>
<tr><td><b>wrapped_IsAudioStreamProcessed</b></td><td>Check if any audio stream buffers requires refill</td><td>IsAudioStreamProcessed</td><td>bool</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_PlayAudioStream</b></td><td>Play audio stream</td><td>PlayAudioStream</td><td>void</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_PauseAudioStream</b></td><td>Pause audio stream</td><td>PauseAudioStream</td><td>void</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_ResumeAudioStream</b></td><td>Resume audio stream</td><td>ResumeAudioStream</td><td>void</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_IsAudioStreamPlaying</b></td><td>Check if audio stream is playing</td><td>IsAudioStreamPlaying</td><td>bool</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_StopAudioStream</b></td><td>Stop audio stream</td><td>StopAudioStream</td><td>void</td><td><ul><li>stream: AudioStream*</li></ul></td></tr>
<tr><td><b>wrapped_SetAudioStreamVolume</b></td><td>Set volume for audio stream (1.0 is max level)</td><td>SetAudioStreamVolume</td><td>void</td><td><ul><li>stream: AudioStream*</li>
<li>volume: float</li></ul></td></tr>
<tr><td><b>wrapped_SetAudioStreamPitch</b></td><td>Set pitch for audio stream (1.0 is base level)</td><td>SetAudioStreamPitch</td><td>void</td><td><ul><li>stream: AudioStream*</li>
<li>pitch: float</li></ul></td></tr>
<tr><td><b>wrapped_SetAudioStreamPan</b></td><td>Set pan for audio stream (0.5 is centered)</td><td>SetAudioStreamPan</td><td>void</td><td><ul><li>stream: AudioStream*</li>
<li>pan: float</li></ul></td></tr>
<tr><td><b>wrapped_SetAudioStreamCallback</b></td><td>Audio thread callback to request new data</td><td>SetAudioStreamCallback</td><td>void</td><td><ul><li>stream: AudioStream*</li>
<li>callback: AudioCallback*</li></ul></td></tr>
<tr><td><b>wrapped_AttachAudioStreamProcessor</b></td><td>Attach audio stream processor to stream, receives the samples as <float>s</td><td>AttachAudioStreamProcessor</td><td>void</td><td><ul><li>stream: AudioStream*</li>
<li>processor: AudioCallback*</li></ul></td></tr>
<tr><td><b>wrapped_DetachAudioStreamProcessor</b></td><td>Detach audio stream processor from stream</td><td>DetachAudioStreamProcessor</td><td>void</td><td><ul><li>stream: AudioStream*</li>
<li>processor: AudioCallback*</li></ul></td></tr>
<tr><td><b>wrapped_AttachAudioMixedProcessor</b></td><td>Attach audio stream processor to the entire audio pipeline, receives the samples as <float>s</td><td>AttachAudioMixedProcessor</td><td>void</td><td><ul><li>processor: AudioCallback*</li></ul></td></tr>
<tr><td><b>wrapped_DetachAudioMixedProcessor</b></td><td>Detach audio stream processor from the entire audio pipeline</td><td>DetachAudioMixedProcessor</td><td>void</td><td><ul><li>processor: AudioCallback*</li></ul></td></tr>
<tr><td><b>wrapped_alloc</b></td><td>alloc</td><td>Allocate memory, cleared on every WindowShouldClose call (your frame update-loop)</td><td>void*</td><td><ul><li title="The size (in bytes) to allocate">size: unsigned int</li></ul></td></tr>
<tr><td><b>wrapped_free</b></td><td>free</td><td>Clear allocated memory. If it was not allocated (or has already been freed) this will error.</td><td>void</td><td><ul><li title="The pointer to free">pointer: void*</li></ul></td></tr>
<tr><td><b>wrapped_WindowShouldClose</b></td><td>WindowShouldClose</td><td>Check if application should close (KEY_ESCAPE pressed or windows close icon clicked.) This also clears memory that was allocated since last call.</td><td>bool</td><td><ul></ul></td></tr>
</table>
  <br>

<h2 id=struct_utils><a href="#top">struct_utils</a></h2>
<table>
	<tr><th>name</th><th>description</th><th>returnType</th><th>params</th></tr>
	<tr><td><b>Vector2_size</b></td><td>Get byte-size of Vector2 struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Vector2_get_x</b></td><td>Getter for Vector2->x</td><td>float</td><td><ul><li>obj: x*</li></ul></td></tr>
<tr><td><b>Vector2_set_x</b></td><td>Setter for Vector2->x</td><td>void</td><td><ul><li>obj: x*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector2_get_y</b></td><td>Getter for Vector2->y</td><td>float</td><td><ul><li>obj: y*</li></ul></td></tr>
<tr><td><b>Vector2_set_y</b></td><td>Setter for Vector2->y</td><td>void</td><td><ul><li>obj: y*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector3_size</b></td><td>Get byte-size of Vector3 struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Vector3_get_x</b></td><td>Getter for Vector3->x</td><td>float</td><td><ul><li>obj: x*</li></ul></td></tr>
<tr><td><b>Vector3_set_x</b></td><td>Setter for Vector3->x</td><td>void</td><td><ul><li>obj: x*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector3_get_y</b></td><td>Getter for Vector3->y</td><td>float</td><td><ul><li>obj: y*</li></ul></td></tr>
<tr><td><b>Vector3_set_y</b></td><td>Setter for Vector3->y</td><td>void</td><td><ul><li>obj: y*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector3_get_z</b></td><td>Getter for Vector3->z</td><td>float</td><td><ul><li>obj: z*</li></ul></td></tr>
<tr><td><b>Vector3_set_z</b></td><td>Setter for Vector3->z</td><td>void</td><td><ul><li>obj: z*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector4_size</b></td><td>Get byte-size of Vector4 struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Vector4_get_x</b></td><td>Getter for Vector4->x</td><td>float</td><td><ul><li>obj: x*</li></ul></td></tr>
<tr><td><b>Vector4_set_x</b></td><td>Setter for Vector4->x</td><td>void</td><td><ul><li>obj: x*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector4_get_y</b></td><td>Getter for Vector4->y</td><td>float</td><td><ul><li>obj: y*</li></ul></td></tr>
<tr><td><b>Vector4_set_y</b></td><td>Setter for Vector4->y</td><td>void</td><td><ul><li>obj: y*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector4_get_z</b></td><td>Getter for Vector4->z</td><td>float</td><td><ul><li>obj: z*</li></ul></td></tr>
<tr><td><b>Vector4_set_z</b></td><td>Setter for Vector4->z</td><td>void</td><td><ul><li>obj: z*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Vector4_get_w</b></td><td>Getter for Vector4->w</td><td>float</td><td><ul><li>obj: w*</li></ul></td></tr>
<tr><td><b>Vector4_set_w</b></td><td>Setter for Vector4->w</td><td>void</td><td><ul><li>obj: w*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_size</b></td><td>Get byte-size of Matrix struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Matrix_get_m0</b></td><td>Getter for Matrix->m0</td><td>float</td><td><ul><li>obj: m0*</li></ul></td></tr>
<tr><td><b>Matrix_set_m0</b></td><td>Setter for Matrix->m0</td><td>void</td><td><ul><li>obj: m0*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m4</b></td><td>Getter for Matrix->m4</td><td>float</td><td><ul><li>obj: m4*</li></ul></td></tr>
<tr><td><b>Matrix_set_m4</b></td><td>Setter for Matrix->m4</td><td>void</td><td><ul><li>obj: m4*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m8</b></td><td>Getter for Matrix->m8</td><td>float</td><td><ul><li>obj: m8*</li></ul></td></tr>
<tr><td><b>Matrix_set_m8</b></td><td>Setter for Matrix->m8</td><td>void</td><td><ul><li>obj: m8*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m12</b></td><td>Getter for Matrix->m12</td><td>float</td><td><ul><li>obj: m12*</li></ul></td></tr>
<tr><td><b>Matrix_set_m12</b></td><td>Setter for Matrix->m12</td><td>void</td><td><ul><li>obj: m12*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m1</b></td><td>Getter for Matrix->m1</td><td>float</td><td><ul><li>obj: m1*</li></ul></td></tr>
<tr><td><b>Matrix_set_m1</b></td><td>Setter for Matrix->m1</td><td>void</td><td><ul><li>obj: m1*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m5</b></td><td>Getter for Matrix->m5</td><td>float</td><td><ul><li>obj: m5*</li></ul></td></tr>
<tr><td><b>Matrix_set_m5</b></td><td>Setter for Matrix->m5</td><td>void</td><td><ul><li>obj: m5*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m9</b></td><td>Getter for Matrix->m9</td><td>float</td><td><ul><li>obj: m9*</li></ul></td></tr>
<tr><td><b>Matrix_set_m9</b></td><td>Setter for Matrix->m9</td><td>void</td><td><ul><li>obj: m9*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m13</b></td><td>Getter for Matrix->m13</td><td>float</td><td><ul><li>obj: m13*</li></ul></td></tr>
<tr><td><b>Matrix_set_m13</b></td><td>Setter for Matrix->m13</td><td>void</td><td><ul><li>obj: m13*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m2</b></td><td>Getter for Matrix->m2</td><td>float</td><td><ul><li>obj: m2*</li></ul></td></tr>
<tr><td><b>Matrix_set_m2</b></td><td>Setter for Matrix->m2</td><td>void</td><td><ul><li>obj: m2*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m6</b></td><td>Getter for Matrix->m6</td><td>float</td><td><ul><li>obj: m6*</li></ul></td></tr>
<tr><td><b>Matrix_set_m6</b></td><td>Setter for Matrix->m6</td><td>void</td><td><ul><li>obj: m6*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m10</b></td><td>Getter for Matrix->m10</td><td>float</td><td><ul><li>obj: m10*</li></ul></td></tr>
<tr><td><b>Matrix_set_m10</b></td><td>Setter for Matrix->m10</td><td>void</td><td><ul><li>obj: m10*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m14</b></td><td>Getter for Matrix->m14</td><td>float</td><td><ul><li>obj: m14*</li></ul></td></tr>
<tr><td><b>Matrix_set_m14</b></td><td>Setter for Matrix->m14</td><td>void</td><td><ul><li>obj: m14*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m3</b></td><td>Getter for Matrix->m3</td><td>float</td><td><ul><li>obj: m3*</li></ul></td></tr>
<tr><td><b>Matrix_set_m3</b></td><td>Setter for Matrix->m3</td><td>void</td><td><ul><li>obj: m3*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m7</b></td><td>Getter for Matrix->m7</td><td>float</td><td><ul><li>obj: m7*</li></ul></td></tr>
<tr><td><b>Matrix_set_m7</b></td><td>Setter for Matrix->m7</td><td>void</td><td><ul><li>obj: m7*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m11</b></td><td>Getter for Matrix->m11</td><td>float</td><td><ul><li>obj: m11*</li></ul></td></tr>
<tr><td><b>Matrix_set_m11</b></td><td>Setter for Matrix->m11</td><td>void</td><td><ul><li>obj: m11*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Matrix_get_m15</b></td><td>Getter for Matrix->m15</td><td>float</td><td><ul><li>obj: m15*</li></ul></td></tr>
<tr><td><b>Matrix_set_m15</b></td><td>Setter for Matrix->m15</td><td>void</td><td><ul><li>obj: m15*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Color_size</b></td><td>Get byte-size of Color struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Color_get_r</b></td><td>Getter for Color->r</td><td>unsigned char</td><td><ul><li>obj: r*</li></ul></td></tr>
<tr><td><b>Color_set_r</b></td><td>Setter for Color->r</td><td>void</td><td><ul><li>obj: r*</li>
<li>v: unsigned char</li></ul></td></tr>
<tr><td><b>Color_get_g</b></td><td>Getter for Color->g</td><td>unsigned char</td><td><ul><li>obj: g*</li></ul></td></tr>
<tr><td><b>Color_set_g</b></td><td>Setter for Color->g</td><td>void</td><td><ul><li>obj: g*</li>
<li>v: unsigned char</li></ul></td></tr>
<tr><td><b>Color_get_b</b></td><td>Getter for Color->b</td><td>unsigned char</td><td><ul><li>obj: b*</li></ul></td></tr>
<tr><td><b>Color_set_b</b></td><td>Setter for Color->b</td><td>void</td><td><ul><li>obj: b*</li>
<li>v: unsigned char</li></ul></td></tr>
<tr><td><b>Color_get_a</b></td><td>Getter for Color->a</td><td>unsigned char</td><td><ul><li>obj: a*</li></ul></td></tr>
<tr><td><b>Color_set_a</b></td><td>Setter for Color->a</td><td>void</td><td><ul><li>obj: a*</li>
<li>v: unsigned char</li></ul></td></tr>
<tr><td><b>Rectangle_size</b></td><td>Get byte-size of Rectangle struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Rectangle_get_x</b></td><td>Getter for Rectangle->x</td><td>float</td><td><ul><li>obj: x*</li></ul></td></tr>
<tr><td><b>Rectangle_set_x</b></td><td>Setter for Rectangle->x</td><td>void</td><td><ul><li>obj: x*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Rectangle_get_y</b></td><td>Getter for Rectangle->y</td><td>float</td><td><ul><li>obj: y*</li></ul></td></tr>
<tr><td><b>Rectangle_set_y</b></td><td>Setter for Rectangle->y</td><td>void</td><td><ul><li>obj: y*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Rectangle_get_width</b></td><td>Getter for Rectangle->width</td><td>float</td><td><ul><li>obj: width*</li></ul></td></tr>
<tr><td><b>Rectangle_set_width</b></td><td>Setter for Rectangle->width</td><td>void</td><td><ul><li>obj: width*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Rectangle_get_height</b></td><td>Getter for Rectangle->height</td><td>float</td><td><ul><li>obj: height*</li></ul></td></tr>
<tr><td><b>Rectangle_set_height</b></td><td>Setter for Rectangle->height</td><td>void</td><td><ul><li>obj: height*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Image_size</b></td><td>Get byte-size of Image struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Image_get_data</b></td><td>Getter for Image->data</td><td>void *</td><td><ul><li>obj: data*</li></ul></td></tr>
<tr><td><b>Image_set_data</b></td><td>Setter for Image->data</td><td>void</td><td><ul><li>obj: data*</li>
<li>v: void *</li></ul></td></tr>
<tr><td><b>Image_get_width</b></td><td>Getter for Image->width</td><td>int</td><td><ul><li>obj: width*</li></ul></td></tr>
<tr><td><b>Image_set_width</b></td><td>Setter for Image->width</td><td>void</td><td><ul><li>obj: width*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Image_get_height</b></td><td>Getter for Image->height</td><td>int</td><td><ul><li>obj: height*</li></ul></td></tr>
<tr><td><b>Image_set_height</b></td><td>Setter for Image->height</td><td>void</td><td><ul><li>obj: height*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Image_get_mipmaps</b></td><td>Getter for Image->mipmaps</td><td>int</td><td><ul><li>obj: mipmaps*</li></ul></td></tr>
<tr><td><b>Image_set_mipmaps</b></td><td>Setter for Image->mipmaps</td><td>void</td><td><ul><li>obj: mipmaps*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Image_get_format</b></td><td>Getter for Image->format</td><td>int</td><td><ul><li>obj: format*</li></ul></td></tr>
<tr><td><b>Image_set_format</b></td><td>Setter for Image->format</td><td>void</td><td><ul><li>obj: format*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Texture_size</b></td><td>Get byte-size of Texture struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Texture_get_id</b></td><td>Getter for Texture->id</td><td>unsigned int</td><td><ul><li>obj: id*</li></ul></td></tr>
<tr><td><b>Texture_set_id</b></td><td>Setter for Texture->id</td><td>void</td><td><ul><li>obj: id*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Texture_get_width</b></td><td>Getter for Texture->width</td><td>int</td><td><ul><li>obj: width*</li></ul></td></tr>
<tr><td><b>Texture_set_width</b></td><td>Setter for Texture->width</td><td>void</td><td><ul><li>obj: width*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Texture_get_height</b></td><td>Getter for Texture->height</td><td>int</td><td><ul><li>obj: height*</li></ul></td></tr>
<tr><td><b>Texture_set_height</b></td><td>Setter for Texture->height</td><td>void</td><td><ul><li>obj: height*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Texture_get_mipmaps</b></td><td>Getter for Texture->mipmaps</td><td>int</td><td><ul><li>obj: mipmaps*</li></ul></td></tr>
<tr><td><b>Texture_set_mipmaps</b></td><td>Setter for Texture->mipmaps</td><td>void</td><td><ul><li>obj: mipmaps*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Texture_get_format</b></td><td>Getter for Texture->format</td><td>int</td><td><ul><li>obj: format*</li></ul></td></tr>
<tr><td><b>Texture_set_format</b></td><td>Setter for Texture->format</td><td>void</td><td><ul><li>obj: format*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>RenderTexture_size</b></td><td>Get byte-size of RenderTexture struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>RenderTexture_get_id</b></td><td>Getter for RenderTexture->id</td><td>unsigned int</td><td><ul><li>obj: id*</li></ul></td></tr>
<tr><td><b>RenderTexture_set_id</b></td><td>Setter for RenderTexture->id</td><td>void</td><td><ul><li>obj: id*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>RenderTexture_get_texture</b></td><td>Getter for RenderTexture->texture</td><td>Texture</td><td><ul><li>obj: texture*</li></ul></td></tr>
<tr><td><b>RenderTexture_set_texture</b></td><td>Setter for RenderTexture->texture</td><td>void</td><td><ul><li>obj: texture*</li>
<li>v: Texture</li></ul></td></tr>
<tr><td><b>RenderTexture_get_depth</b></td><td>Getter for RenderTexture->depth</td><td>Texture</td><td><ul><li>obj: depth*</li></ul></td></tr>
<tr><td><b>RenderTexture_set_depth</b></td><td>Setter for RenderTexture->depth</td><td>void</td><td><ul><li>obj: depth*</li>
<li>v: Texture</li></ul></td></tr>
<tr><td><b>NPatchInfo_size</b></td><td>Get byte-size of NPatchInfo struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>NPatchInfo_get_source</b></td><td>Getter for NPatchInfo->source</td><td>Rectangle</td><td><ul><li>obj: source*</li></ul></td></tr>
<tr><td><b>NPatchInfo_set_source</b></td><td>Setter for NPatchInfo->source</td><td>void</td><td><ul><li>obj: source*</li>
<li>v: Rectangle</li></ul></td></tr>
<tr><td><b>NPatchInfo_get_left</b></td><td>Getter for NPatchInfo->left</td><td>int</td><td><ul><li>obj: left*</li></ul></td></tr>
<tr><td><b>NPatchInfo_set_left</b></td><td>Setter for NPatchInfo->left</td><td>void</td><td><ul><li>obj: left*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>NPatchInfo_get_top</b></td><td>Getter for NPatchInfo->top</td><td>int</td><td><ul><li>obj: top*</li></ul></td></tr>
<tr><td><b>NPatchInfo_set_top</b></td><td>Setter for NPatchInfo->top</td><td>void</td><td><ul><li>obj: top*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>NPatchInfo_get_right</b></td><td>Getter for NPatchInfo->right</td><td>int</td><td><ul><li>obj: right*</li></ul></td></tr>
<tr><td><b>NPatchInfo_set_right</b></td><td>Setter for NPatchInfo->right</td><td>void</td><td><ul><li>obj: right*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>NPatchInfo_get_bottom</b></td><td>Getter for NPatchInfo->bottom</td><td>int</td><td><ul><li>obj: bottom*</li></ul></td></tr>
<tr><td><b>NPatchInfo_set_bottom</b></td><td>Setter for NPatchInfo->bottom</td><td>void</td><td><ul><li>obj: bottom*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>NPatchInfo_get_layout</b></td><td>Getter for NPatchInfo->layout</td><td>int</td><td><ul><li>obj: layout*</li></ul></td></tr>
<tr><td><b>NPatchInfo_set_layout</b></td><td>Setter for NPatchInfo->layout</td><td>void</td><td><ul><li>obj: layout*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>GlyphInfo_size</b></td><td>Get byte-size of GlyphInfo struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>GlyphInfo_get_value</b></td><td>Getter for GlyphInfo->value</td><td>int</td><td><ul><li>obj: value*</li></ul></td></tr>
<tr><td><b>GlyphInfo_set_value</b></td><td>Setter for GlyphInfo->value</td><td>void</td><td><ul><li>obj: value*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>GlyphInfo_get_offsetX</b></td><td>Getter for GlyphInfo->offsetX</td><td>int</td><td><ul><li>obj: offsetX*</li></ul></td></tr>
<tr><td><b>GlyphInfo_set_offsetX</b></td><td>Setter for GlyphInfo->offsetX</td><td>void</td><td><ul><li>obj: offsetX*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>GlyphInfo_get_offsetY</b></td><td>Getter for GlyphInfo->offsetY</td><td>int</td><td><ul><li>obj: offsetY*</li></ul></td></tr>
<tr><td><b>GlyphInfo_set_offsetY</b></td><td>Setter for GlyphInfo->offsetY</td><td>void</td><td><ul><li>obj: offsetY*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>GlyphInfo_get_advanceX</b></td><td>Getter for GlyphInfo->advanceX</td><td>int</td><td><ul><li>obj: advanceX*</li></ul></td></tr>
<tr><td><b>GlyphInfo_set_advanceX</b></td><td>Setter for GlyphInfo->advanceX</td><td>void</td><td><ul><li>obj: advanceX*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>GlyphInfo_get_image</b></td><td>Getter for GlyphInfo->image</td><td>Image</td><td><ul><li>obj: image*</li></ul></td></tr>
<tr><td><b>GlyphInfo_set_image</b></td><td>Setter for GlyphInfo->image</td><td>void</td><td><ul><li>obj: image*</li>
<li>v: Image</li></ul></td></tr>
<tr><td><b>Font_size</b></td><td>Get byte-size of Font struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Font_get_baseSize</b></td><td>Getter for Font->baseSize</td><td>int</td><td><ul><li>obj: baseSize*</li></ul></td></tr>
<tr><td><b>Font_set_baseSize</b></td><td>Setter for Font->baseSize</td><td>void</td><td><ul><li>obj: baseSize*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Font_get_glyphCount</b></td><td>Getter for Font->glyphCount</td><td>int</td><td><ul><li>obj: glyphCount*</li></ul></td></tr>
<tr><td><b>Font_set_glyphCount</b></td><td>Setter for Font->glyphCount</td><td>void</td><td><ul><li>obj: glyphCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Font_get_glyphPadding</b></td><td>Getter for Font->glyphPadding</td><td>int</td><td><ul><li>obj: glyphPadding*</li></ul></td></tr>
<tr><td><b>Font_set_glyphPadding</b></td><td>Setter for Font->glyphPadding</td><td>void</td><td><ul><li>obj: glyphPadding*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Font_get_texture</b></td><td>Getter for Font->texture</td><td>Texture2D</td><td><ul><li>obj: texture*</li></ul></td></tr>
<tr><td><b>Font_set_texture</b></td><td>Setter for Font->texture</td><td>void</td><td><ul><li>obj: texture*</li>
<li>v: Texture2D</li></ul></td></tr>
<tr><td><b>Font_get_recs</b></td><td>Getter for Font->recs</td><td>Rectangle *</td><td><ul><li>obj: recs*</li></ul></td></tr>
<tr><td><b>Font_set_recs</b></td><td>Setter for Font->recs</td><td>void</td><td><ul><li>obj: recs*</li>
<li>v: Rectangle *</li></ul></td></tr>
<tr><td><b>Font_get_glyphs</b></td><td>Getter for Font->glyphs</td><td>GlyphInfo *</td><td><ul><li>obj: glyphs*</li></ul></td></tr>
<tr><td><b>Font_set_glyphs</b></td><td>Setter for Font->glyphs</td><td>void</td><td><ul><li>obj: glyphs*</li>
<li>v: GlyphInfo *</li></ul></td></tr>
<tr><td><b>Camera3D_size</b></td><td>Get byte-size of Camera3D struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Camera3D_get_position</b></td><td>Getter for Camera3D->position</td><td>Vector3</td><td><ul><li>obj: position*</li></ul></td></tr>
<tr><td><b>Camera3D_set_position</b></td><td>Setter for Camera3D->position</td><td>void</td><td><ul><li>obj: position*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>Camera3D_get_target</b></td><td>Getter for Camera3D->target</td><td>Vector3</td><td><ul><li>obj: target*</li></ul></td></tr>
<tr><td><b>Camera3D_set_target</b></td><td>Setter for Camera3D->target</td><td>void</td><td><ul><li>obj: target*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>Camera3D_get_up</b></td><td>Getter for Camera3D->up</td><td>Vector3</td><td><ul><li>obj: up*</li></ul></td></tr>
<tr><td><b>Camera3D_set_up</b></td><td>Setter for Camera3D->up</td><td>void</td><td><ul><li>obj: up*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>Camera3D_get_fovy</b></td><td>Getter for Camera3D->fovy</td><td>float</td><td><ul><li>obj: fovy*</li></ul></td></tr>
<tr><td><b>Camera3D_set_fovy</b></td><td>Setter for Camera3D->fovy</td><td>void</td><td><ul><li>obj: fovy*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Camera3D_get_projection</b></td><td>Getter for Camera3D->projection</td><td>int</td><td><ul><li>obj: projection*</li></ul></td></tr>
<tr><td><b>Camera3D_set_projection</b></td><td>Setter for Camera3D->projection</td><td>void</td><td><ul><li>obj: projection*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Camera2D_size</b></td><td>Get byte-size of Camera2D struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Camera2D_get_offset</b></td><td>Getter for Camera2D->offset</td><td>Vector2</td><td><ul><li>obj: offset*</li></ul></td></tr>
<tr><td><b>Camera2D_set_offset</b></td><td>Setter for Camera2D->offset</td><td>void</td><td><ul><li>obj: offset*</li>
<li>v: Vector2</li></ul></td></tr>
<tr><td><b>Camera2D_get_target</b></td><td>Getter for Camera2D->target</td><td>Vector2</td><td><ul><li>obj: target*</li></ul></td></tr>
<tr><td><b>Camera2D_set_target</b></td><td>Setter for Camera2D->target</td><td>void</td><td><ul><li>obj: target*</li>
<li>v: Vector2</li></ul></td></tr>
<tr><td><b>Camera2D_get_rotation</b></td><td>Getter for Camera2D->rotation</td><td>float</td><td><ul><li>obj: rotation*</li></ul></td></tr>
<tr><td><b>Camera2D_set_rotation</b></td><td>Setter for Camera2D->rotation</td><td>void</td><td><ul><li>obj: rotation*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Camera2D_get_zoom</b></td><td>Getter for Camera2D->zoom</td><td>float</td><td><ul><li>obj: zoom*</li></ul></td></tr>
<tr><td><b>Camera2D_set_zoom</b></td><td>Setter for Camera2D->zoom</td><td>void</td><td><ul><li>obj: zoom*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Mesh_size</b></td><td>Get byte-size of Mesh struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Mesh_get_vertexCount</b></td><td>Getter for Mesh->vertexCount</td><td>int</td><td><ul><li>obj: vertexCount*</li></ul></td></tr>
<tr><td><b>Mesh_set_vertexCount</b></td><td>Setter for Mesh->vertexCount</td><td>void</td><td><ul><li>obj: vertexCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Mesh_get_triangleCount</b></td><td>Getter for Mesh->triangleCount</td><td>int</td><td><ul><li>obj: triangleCount*</li></ul></td></tr>
<tr><td><b>Mesh_set_triangleCount</b></td><td>Setter for Mesh->triangleCount</td><td>void</td><td><ul><li>obj: triangleCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Mesh_get_vertices</b></td><td>Getter for Mesh->vertices</td><td>float *</td><td><ul><li>obj: vertices*</li></ul></td></tr>
<tr><td><b>Mesh_set_vertices</b></td><td>Setter for Mesh->vertices</td><td>void</td><td><ul><li>obj: vertices*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_texcoords</b></td><td>Getter for Mesh->texcoords</td><td>float *</td><td><ul><li>obj: texcoords*</li></ul></td></tr>
<tr><td><b>Mesh_set_texcoords</b></td><td>Setter for Mesh->texcoords</td><td>void</td><td><ul><li>obj: texcoords*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_texcoords2</b></td><td>Getter for Mesh->texcoords2</td><td>float *</td><td><ul><li>obj: texcoords2*</li></ul></td></tr>
<tr><td><b>Mesh_set_texcoords2</b></td><td>Setter for Mesh->texcoords2</td><td>void</td><td><ul><li>obj: texcoords2*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_normals</b></td><td>Getter for Mesh->normals</td><td>float *</td><td><ul><li>obj: normals*</li></ul></td></tr>
<tr><td><b>Mesh_set_normals</b></td><td>Setter for Mesh->normals</td><td>void</td><td><ul><li>obj: normals*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_tangents</b></td><td>Getter for Mesh->tangents</td><td>float *</td><td><ul><li>obj: tangents*</li></ul></td></tr>
<tr><td><b>Mesh_set_tangents</b></td><td>Setter for Mesh->tangents</td><td>void</td><td><ul><li>obj: tangents*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_colors</b></td><td>Getter for Mesh->colors</td><td>unsigned char *</td><td><ul><li>obj: colors*</li></ul></td></tr>
<tr><td><b>Mesh_set_colors</b></td><td>Setter for Mesh->colors</td><td>void</td><td><ul><li>obj: colors*</li>
<li>v: unsigned char *</li></ul></td></tr>
<tr><td><b>Mesh_get_indices</b></td><td>Getter for Mesh->indices</td><td>unsigned short *</td><td><ul><li>obj: indices*</li></ul></td></tr>
<tr><td><b>Mesh_set_indices</b></td><td>Setter for Mesh->indices</td><td>void</td><td><ul><li>obj: indices*</li>
<li>v: unsigned short *</li></ul></td></tr>
<tr><td><b>Mesh_get_animVertices</b></td><td>Getter for Mesh->animVertices</td><td>float *</td><td><ul><li>obj: animVertices*</li></ul></td></tr>
<tr><td><b>Mesh_set_animVertices</b></td><td>Setter for Mesh->animVertices</td><td>void</td><td><ul><li>obj: animVertices*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_animNormals</b></td><td>Getter for Mesh->animNormals</td><td>float *</td><td><ul><li>obj: animNormals*</li></ul></td></tr>
<tr><td><b>Mesh_set_animNormals</b></td><td>Setter for Mesh->animNormals</td><td>void</td><td><ul><li>obj: animNormals*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_boneIds</b></td><td>Getter for Mesh->boneIds</td><td>unsigned char *</td><td><ul><li>obj: boneIds*</li></ul></td></tr>
<tr><td><b>Mesh_set_boneIds</b></td><td>Setter for Mesh->boneIds</td><td>void</td><td><ul><li>obj: boneIds*</li>
<li>v: unsigned char *</li></ul></td></tr>
<tr><td><b>Mesh_get_boneWeights</b></td><td>Getter for Mesh->boneWeights</td><td>float *</td><td><ul><li>obj: boneWeights*</li></ul></td></tr>
<tr><td><b>Mesh_set_boneWeights</b></td><td>Setter for Mesh->boneWeights</td><td>void</td><td><ul><li>obj: boneWeights*</li>
<li>v: float *</li></ul></td></tr>
<tr><td><b>Mesh_get_vaoId</b></td><td>Getter for Mesh->vaoId</td><td>unsigned int</td><td><ul><li>obj: vaoId*</li></ul></td></tr>
<tr><td><b>Mesh_set_vaoId</b></td><td>Setter for Mesh->vaoId</td><td>void</td><td><ul><li>obj: vaoId*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Mesh_get_vboId</b></td><td>Getter for Mesh->vboId</td><td>unsigned int *</td><td><ul><li>obj: vboId*</li></ul></td></tr>
<tr><td><b>Mesh_set_vboId</b></td><td>Setter for Mesh->vboId</td><td>void</td><td><ul><li>obj: vboId*</li>
<li>v: unsigned int *</li></ul></td></tr>
<tr><td><b>Shader_size</b></td><td>Get byte-size of Shader struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Shader_get_id</b></td><td>Getter for Shader->id</td><td>unsigned int</td><td><ul><li>obj: id*</li></ul></td></tr>
<tr><td><b>Shader_set_id</b></td><td>Setter for Shader->id</td><td>void</td><td><ul><li>obj: id*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Shader_get_locs</b></td><td>Getter for Shader->locs</td><td>int *</td><td><ul><li>obj: locs*</li></ul></td></tr>
<tr><td><b>Shader_set_locs</b></td><td>Setter for Shader->locs</td><td>void</td><td><ul><li>obj: locs*</li>
<li>v: int *</li></ul></td></tr>
<tr><td><b>MaterialMap_size</b></td><td>Get byte-size of MaterialMap struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>MaterialMap_get_texture</b></td><td>Getter for MaterialMap->texture</td><td>Texture2D</td><td><ul><li>obj: texture*</li></ul></td></tr>
<tr><td><b>MaterialMap_set_texture</b></td><td>Setter for MaterialMap->texture</td><td>void</td><td><ul><li>obj: texture*</li>
<li>v: Texture2D</li></ul></td></tr>
<tr><td><b>MaterialMap_get_color</b></td><td>Getter for MaterialMap->color</td><td>Color</td><td><ul><li>obj: color*</li></ul></td></tr>
<tr><td><b>MaterialMap_set_color</b></td><td>Setter for MaterialMap->color</td><td>void</td><td><ul><li>obj: color*</li>
<li>v: Color</li></ul></td></tr>
<tr><td><b>MaterialMap_get_value</b></td><td>Getter for MaterialMap->value</td><td>float</td><td><ul><li>obj: value*</li></ul></td></tr>
<tr><td><b>MaterialMap_set_value</b></td><td>Setter for MaterialMap->value</td><td>void</td><td><ul><li>obj: value*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>Material_size</b></td><td>Get byte-size of Material struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Material_get_shader</b></td><td>Getter for Material->shader</td><td>Shader</td><td><ul><li>obj: shader*</li></ul></td></tr>
<tr><td><b>Material_set_shader</b></td><td>Setter for Material->shader</td><td>void</td><td><ul><li>obj: shader*</li>
<li>v: Shader</li></ul></td></tr>
<tr><td><b>Material_get_maps</b></td><td>Getter for Material->maps</td><td>MaterialMap *</td><td><ul><li>obj: maps*</li></ul></td></tr>
<tr><td><b>Material_set_maps</b></td><td>Setter for Material->maps</td><td>void</td><td><ul><li>obj: maps*</li>
<li>v: MaterialMap *</li></ul></td></tr>
<tr><td><b>Material_get_params</b></td><td>Getter for Material->params</td><td>float[4]</td><td><ul><li>obj: params*</li></ul></td></tr>
<tr><td><b>Material_set_params</b></td><td>Setter for Material->params</td><td>void</td><td><ul><li>obj: params*</li>
<li>v: float[4]</li></ul></td></tr>
<tr><td><b>Transform_size</b></td><td>Get byte-size of Transform struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Transform_get_translation</b></td><td>Getter for Transform->translation</td><td>Vector3</td><td><ul><li>obj: translation*</li></ul></td></tr>
<tr><td><b>Transform_set_translation</b></td><td>Setter for Transform->translation</td><td>void</td><td><ul><li>obj: translation*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>Transform_get_rotation</b></td><td>Getter for Transform->rotation</td><td>Quaternion</td><td><ul><li>obj: rotation*</li></ul></td></tr>
<tr><td><b>Transform_set_rotation</b></td><td>Setter for Transform->rotation</td><td>void</td><td><ul><li>obj: rotation*</li>
<li>v: Quaternion</li></ul></td></tr>
<tr><td><b>Transform_get_scale</b></td><td>Getter for Transform->scale</td><td>Vector3</td><td><ul><li>obj: scale*</li></ul></td></tr>
<tr><td><b>Transform_set_scale</b></td><td>Setter for Transform->scale</td><td>void</td><td><ul><li>obj: scale*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>BoneInfo_size</b></td><td>Get byte-size of BoneInfo struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>BoneInfo_get_name</b></td><td>Getter for BoneInfo->name</td><td>char[32]</td><td><ul><li>obj: name*</li></ul></td></tr>
<tr><td><b>BoneInfo_set_name</b></td><td>Setter for BoneInfo->name</td><td>void</td><td><ul><li>obj: name*</li>
<li>v: char[32]</li></ul></td></tr>
<tr><td><b>BoneInfo_get_parent</b></td><td>Getter for BoneInfo->parent</td><td>int</td><td><ul><li>obj: parent*</li></ul></td></tr>
<tr><td><b>BoneInfo_set_parent</b></td><td>Setter for BoneInfo->parent</td><td>void</td><td><ul><li>obj: parent*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Model_size</b></td><td>Get byte-size of Model struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Model_get_transform</b></td><td>Getter for Model->transform</td><td>Matrix</td><td><ul><li>obj: transform*</li></ul></td></tr>
<tr><td><b>Model_set_transform</b></td><td>Setter for Model->transform</td><td>void</td><td><ul><li>obj: transform*</li>
<li>v: Matrix</li></ul></td></tr>
<tr><td><b>Model_get_meshCount</b></td><td>Getter for Model->meshCount</td><td>int</td><td><ul><li>obj: meshCount*</li></ul></td></tr>
<tr><td><b>Model_set_meshCount</b></td><td>Setter for Model->meshCount</td><td>void</td><td><ul><li>obj: meshCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Model_get_materialCount</b></td><td>Getter for Model->materialCount</td><td>int</td><td><ul><li>obj: materialCount*</li></ul></td></tr>
<tr><td><b>Model_set_materialCount</b></td><td>Setter for Model->materialCount</td><td>void</td><td><ul><li>obj: materialCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Model_get_meshes</b></td><td>Getter for Model->meshes</td><td>Mesh *</td><td><ul><li>obj: meshes*</li></ul></td></tr>
<tr><td><b>Model_set_meshes</b></td><td>Setter for Model->meshes</td><td>void</td><td><ul><li>obj: meshes*</li>
<li>v: Mesh *</li></ul></td></tr>
<tr><td><b>Model_get_materials</b></td><td>Getter for Model->materials</td><td>Material *</td><td><ul><li>obj: materials*</li></ul></td></tr>
<tr><td><b>Model_set_materials</b></td><td>Setter for Model->materials</td><td>void</td><td><ul><li>obj: materials*</li>
<li>v: Material *</li></ul></td></tr>
<tr><td><b>Model_get_meshMaterial</b></td><td>Getter for Model->meshMaterial</td><td>int *</td><td><ul><li>obj: meshMaterial*</li></ul></td></tr>
<tr><td><b>Model_set_meshMaterial</b></td><td>Setter for Model->meshMaterial</td><td>void</td><td><ul><li>obj: meshMaterial*</li>
<li>v: int *</li></ul></td></tr>
<tr><td><b>Model_get_boneCount</b></td><td>Getter for Model->boneCount</td><td>int</td><td><ul><li>obj: boneCount*</li></ul></td></tr>
<tr><td><b>Model_set_boneCount</b></td><td>Setter for Model->boneCount</td><td>void</td><td><ul><li>obj: boneCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Model_get_bones</b></td><td>Getter for Model->bones</td><td>BoneInfo *</td><td><ul><li>obj: bones*</li></ul></td></tr>
<tr><td><b>Model_set_bones</b></td><td>Setter for Model->bones</td><td>void</td><td><ul><li>obj: bones*</li>
<li>v: BoneInfo *</li></ul></td></tr>
<tr><td><b>Model_get_bindPose</b></td><td>Getter for Model->bindPose</td><td>Transform *</td><td><ul><li>obj: bindPose*</li></ul></td></tr>
<tr><td><b>Model_set_bindPose</b></td><td>Setter for Model->bindPose</td><td>void</td><td><ul><li>obj: bindPose*</li>
<li>v: Transform *</li></ul></td></tr>
<tr><td><b>ModelAnimation_size</b></td><td>Get byte-size of ModelAnimation struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>ModelAnimation_get_boneCount</b></td><td>Getter for ModelAnimation->boneCount</td><td>int</td><td><ul><li>obj: boneCount*</li></ul></td></tr>
<tr><td><b>ModelAnimation_set_boneCount</b></td><td>Setter for ModelAnimation->boneCount</td><td>void</td><td><ul><li>obj: boneCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>ModelAnimation_get_frameCount</b></td><td>Getter for ModelAnimation->frameCount</td><td>int</td><td><ul><li>obj: frameCount*</li></ul></td></tr>
<tr><td><b>ModelAnimation_set_frameCount</b></td><td>Setter for ModelAnimation->frameCount</td><td>void</td><td><ul><li>obj: frameCount*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>ModelAnimation_get_bones</b></td><td>Getter for ModelAnimation->bones</td><td>BoneInfo *</td><td><ul><li>obj: bones*</li></ul></td></tr>
<tr><td><b>ModelAnimation_set_bones</b></td><td>Setter for ModelAnimation->bones</td><td>void</td><td><ul><li>obj: bones*</li>
<li>v: BoneInfo *</li></ul></td></tr>
<tr><td><b>ModelAnimation_get_framePoses</b></td><td>Getter for ModelAnimation->framePoses</td><td>Transform **</td><td><ul><li>obj: framePoses*</li></ul></td></tr>
<tr><td><b>ModelAnimation_set_framePoses</b></td><td>Setter for ModelAnimation->framePoses</td><td>void</td><td><ul><li>obj: framePoses*</li>
<li>v: Transform **</li></ul></td></tr>
<tr><td><b>ModelAnimation_get_name</b></td><td>Getter for ModelAnimation->name</td><td>char[32]</td><td><ul><li>obj: name*</li></ul></td></tr>
<tr><td><b>ModelAnimation_set_name</b></td><td>Setter for ModelAnimation->name</td><td>void</td><td><ul><li>obj: name*</li>
<li>v: char[32]</li></ul></td></tr>
<tr><td><b>Ray_size</b></td><td>Get byte-size of Ray struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Ray_get_position</b></td><td>Getter for Ray->position</td><td>Vector3</td><td><ul><li>obj: position*</li></ul></td></tr>
<tr><td><b>Ray_set_position</b></td><td>Setter for Ray->position</td><td>void</td><td><ul><li>obj: position*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>Ray_get_direction</b></td><td>Getter for Ray->direction</td><td>Vector3</td><td><ul><li>obj: direction*</li></ul></td></tr>
<tr><td><b>Ray_set_direction</b></td><td>Setter for Ray->direction</td><td>void</td><td><ul><li>obj: direction*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>RayCollision_size</b></td><td>Get byte-size of RayCollision struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>RayCollision_get_hit</b></td><td>Getter for RayCollision->hit</td><td>bool</td><td><ul><li>obj: hit*</li></ul></td></tr>
<tr><td><b>RayCollision_set_hit</b></td><td>Setter for RayCollision->hit</td><td>void</td><td><ul><li>obj: hit*</li>
<li>v: bool</li></ul></td></tr>
<tr><td><b>RayCollision_get_distance</b></td><td>Getter for RayCollision->distance</td><td>float</td><td><ul><li>obj: distance*</li></ul></td></tr>
<tr><td><b>RayCollision_set_distance</b></td><td>Setter for RayCollision->distance</td><td>void</td><td><ul><li>obj: distance*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>RayCollision_get_point</b></td><td>Getter for RayCollision->point</td><td>Vector3</td><td><ul><li>obj: point*</li></ul></td></tr>
<tr><td><b>RayCollision_set_point</b></td><td>Setter for RayCollision->point</td><td>void</td><td><ul><li>obj: point*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>RayCollision_get_normal</b></td><td>Getter for RayCollision->normal</td><td>Vector3</td><td><ul><li>obj: normal*</li></ul></td></tr>
<tr><td><b>RayCollision_set_normal</b></td><td>Setter for RayCollision->normal</td><td>void</td><td><ul><li>obj: normal*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>BoundingBox_size</b></td><td>Get byte-size of BoundingBox struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>BoundingBox_get_min</b></td><td>Getter for BoundingBox->min</td><td>Vector3</td><td><ul><li>obj: min*</li></ul></td></tr>
<tr><td><b>BoundingBox_set_min</b></td><td>Setter for BoundingBox->min</td><td>void</td><td><ul><li>obj: min*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>BoundingBox_get_max</b></td><td>Getter for BoundingBox->max</td><td>Vector3</td><td><ul><li>obj: max*</li></ul></td></tr>
<tr><td><b>BoundingBox_set_max</b></td><td>Setter for BoundingBox->max</td><td>void</td><td><ul><li>obj: max*</li>
<li>v: Vector3</li></ul></td></tr>
<tr><td><b>Wave_size</b></td><td>Get byte-size of Wave struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Wave_get_frameCount</b></td><td>Getter for Wave->frameCount</td><td>unsigned int</td><td><ul><li>obj: frameCount*</li></ul></td></tr>
<tr><td><b>Wave_set_frameCount</b></td><td>Setter for Wave->frameCount</td><td>void</td><td><ul><li>obj: frameCount*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Wave_get_sampleRate</b></td><td>Getter for Wave->sampleRate</td><td>unsigned int</td><td><ul><li>obj: sampleRate*</li></ul></td></tr>
<tr><td><b>Wave_set_sampleRate</b></td><td>Setter for Wave->sampleRate</td><td>void</td><td><ul><li>obj: sampleRate*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Wave_get_sampleSize</b></td><td>Getter for Wave->sampleSize</td><td>unsigned int</td><td><ul><li>obj: sampleSize*</li></ul></td></tr>
<tr><td><b>Wave_set_sampleSize</b></td><td>Setter for Wave->sampleSize</td><td>void</td><td><ul><li>obj: sampleSize*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Wave_get_channels</b></td><td>Getter for Wave->channels</td><td>unsigned int</td><td><ul><li>obj: channels*</li></ul></td></tr>
<tr><td><b>Wave_set_channels</b></td><td>Setter for Wave->channels</td><td>void</td><td><ul><li>obj: channels*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Wave_get_data</b></td><td>Getter for Wave->data</td><td>void *</td><td><ul><li>obj: data*</li></ul></td></tr>
<tr><td><b>Wave_set_data</b></td><td>Setter for Wave->data</td><td>void</td><td><ul><li>obj: data*</li>
<li>v: void *</li></ul></td></tr>
<tr><td><b>AudioStream_size</b></td><td>Get byte-size of AudioStream struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>AudioStream_get_buffer</b></td><td>Getter for AudioStream->buffer</td><td>rAudioBuffer *</td><td><ul><li>obj: buffer*</li></ul></td></tr>
<tr><td><b>AudioStream_set_buffer</b></td><td>Setter for AudioStream->buffer</td><td>void</td><td><ul><li>obj: buffer*</li>
<li>v: rAudioBuffer *</li></ul></td></tr>
<tr><td><b>AudioStream_get_processor</b></td><td>Getter for AudioStream->processor</td><td>rAudioProcessor *</td><td><ul><li>obj: processor*</li></ul></td></tr>
<tr><td><b>AudioStream_set_processor</b></td><td>Setter for AudioStream->processor</td><td>void</td><td><ul><li>obj: processor*</li>
<li>v: rAudioProcessor *</li></ul></td></tr>
<tr><td><b>AudioStream_get_sampleRate</b></td><td>Getter for AudioStream->sampleRate</td><td>unsigned int</td><td><ul><li>obj: sampleRate*</li></ul></td></tr>
<tr><td><b>AudioStream_set_sampleRate</b></td><td>Setter for AudioStream->sampleRate</td><td>void</td><td><ul><li>obj: sampleRate*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>AudioStream_get_sampleSize</b></td><td>Getter for AudioStream->sampleSize</td><td>unsigned int</td><td><ul><li>obj: sampleSize*</li></ul></td></tr>
<tr><td><b>AudioStream_set_sampleSize</b></td><td>Setter for AudioStream->sampleSize</td><td>void</td><td><ul><li>obj: sampleSize*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>AudioStream_get_channels</b></td><td>Getter for AudioStream->channels</td><td>unsigned int</td><td><ul><li>obj: channels*</li></ul></td></tr>
<tr><td><b>AudioStream_set_channels</b></td><td>Setter for AudioStream->channels</td><td>void</td><td><ul><li>obj: channels*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Sound_size</b></td><td>Get byte-size of Sound struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Sound_get_stream</b></td><td>Getter for Sound->stream</td><td>AudioStream</td><td><ul><li>obj: stream*</li></ul></td></tr>
<tr><td><b>Sound_set_stream</b></td><td>Setter for Sound->stream</td><td>void</td><td><ul><li>obj: stream*</li>
<li>v: AudioStream</li></ul></td></tr>
<tr><td><b>Sound_get_frameCount</b></td><td>Getter for Sound->frameCount</td><td>unsigned int</td><td><ul><li>obj: frameCount*</li></ul></td></tr>
<tr><td><b>Sound_set_frameCount</b></td><td>Setter for Sound->frameCount</td><td>void</td><td><ul><li>obj: frameCount*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Music_size</b></td><td>Get byte-size of Music struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>Music_get_stream</b></td><td>Getter for Music->stream</td><td>AudioStream</td><td><ul><li>obj: stream*</li></ul></td></tr>
<tr><td><b>Music_set_stream</b></td><td>Setter for Music->stream</td><td>void</td><td><ul><li>obj: stream*</li>
<li>v: AudioStream</li></ul></td></tr>
<tr><td><b>Music_get_frameCount</b></td><td>Getter for Music->frameCount</td><td>unsigned int</td><td><ul><li>obj: frameCount*</li></ul></td></tr>
<tr><td><b>Music_set_frameCount</b></td><td>Setter for Music->frameCount</td><td>void</td><td><ul><li>obj: frameCount*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>Music_get_looping</b></td><td>Getter for Music->looping</td><td>bool</td><td><ul><li>obj: looping*</li></ul></td></tr>
<tr><td><b>Music_set_looping</b></td><td>Setter for Music->looping</td><td>void</td><td><ul><li>obj: looping*</li>
<li>v: bool</li></ul></td></tr>
<tr><td><b>Music_get_ctxType</b></td><td>Getter for Music->ctxType</td><td>int</td><td><ul><li>obj: ctxType*</li></ul></td></tr>
<tr><td><b>Music_set_ctxType</b></td><td>Setter for Music->ctxType</td><td>void</td><td><ul><li>obj: ctxType*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>Music_get_ctxData</b></td><td>Getter for Music->ctxData</td><td>void *</td><td><ul><li>obj: ctxData*</li></ul></td></tr>
<tr><td><b>Music_set_ctxData</b></td><td>Setter for Music->ctxData</td><td>void</td><td><ul><li>obj: ctxData*</li>
<li>v: void *</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_size</b></td><td>Get byte-size of VrDeviceInfo struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_hResolution</b></td><td>Getter for VrDeviceInfo->hResolution</td><td>int</td><td><ul><li>obj: hResolution*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_hResolution</b></td><td>Setter for VrDeviceInfo->hResolution</td><td>void</td><td><ul><li>obj: hResolution*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_vResolution</b></td><td>Getter for VrDeviceInfo->vResolution</td><td>int</td><td><ul><li>obj: vResolution*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_vResolution</b></td><td>Setter for VrDeviceInfo->vResolution</td><td>void</td><td><ul><li>obj: vResolution*</li>
<li>v: int</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_hScreenSize</b></td><td>Getter for VrDeviceInfo->hScreenSize</td><td>float</td><td><ul><li>obj: hScreenSize*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_hScreenSize</b></td><td>Setter for VrDeviceInfo->hScreenSize</td><td>void</td><td><ul><li>obj: hScreenSize*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_vScreenSize</b></td><td>Getter for VrDeviceInfo->vScreenSize</td><td>float</td><td><ul><li>obj: vScreenSize*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_vScreenSize</b></td><td>Setter for VrDeviceInfo->vScreenSize</td><td>void</td><td><ul><li>obj: vScreenSize*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_vScreenCenter</b></td><td>Getter for VrDeviceInfo->vScreenCenter</td><td>float</td><td><ul><li>obj: vScreenCenter*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_vScreenCenter</b></td><td>Setter for VrDeviceInfo->vScreenCenter</td><td>void</td><td><ul><li>obj: vScreenCenter*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_eyeToScreenDistance</b></td><td>Getter for VrDeviceInfo->eyeToScreenDistance</td><td>float</td><td><ul><li>obj: eyeToScreenDistance*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_eyeToScreenDistance</b></td><td>Setter for VrDeviceInfo->eyeToScreenDistance</td><td>void</td><td><ul><li>obj: eyeToScreenDistance*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_lensSeparationDistance</b></td><td>Getter for VrDeviceInfo->lensSeparationDistance</td><td>float</td><td><ul><li>obj: lensSeparationDistance*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_lensSeparationDistance</b></td><td>Setter for VrDeviceInfo->lensSeparationDistance</td><td>void</td><td><ul><li>obj: lensSeparationDistance*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_interpupillaryDistance</b></td><td>Getter for VrDeviceInfo->interpupillaryDistance</td><td>float</td><td><ul><li>obj: interpupillaryDistance*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_interpupillaryDistance</b></td><td>Setter for VrDeviceInfo->interpupillaryDistance</td><td>void</td><td><ul><li>obj: interpupillaryDistance*</li>
<li>v: float</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_lensDistortionValues</b></td><td>Getter for VrDeviceInfo->lensDistortionValues</td><td>float[4]</td><td><ul><li>obj: lensDistortionValues*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_lensDistortionValues</b></td><td>Setter for VrDeviceInfo->lensDistortionValues</td><td>void</td><td><ul><li>obj: lensDistortionValues*</li>
<li>v: float[4]</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_get_chromaAbCorrection</b></td><td>Getter for VrDeviceInfo->chromaAbCorrection</td><td>float[4]</td><td><ul><li>obj: chromaAbCorrection*</li></ul></td></tr>
<tr><td><b>VrDeviceInfo_set_chromaAbCorrection</b></td><td>Setter for VrDeviceInfo->chromaAbCorrection</td><td>void</td><td><ul><li>obj: chromaAbCorrection*</li>
<li>v: float[4]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_size</b></td><td>Get byte-size of VrStereoConfig struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>VrStereoConfig_get_projection</b></td><td>Getter for VrStereoConfig->projection</td><td>Matrix[2]</td><td><ul><li>obj: projection*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_projection</b></td><td>Setter for VrStereoConfig->projection</td><td>void</td><td><ul><li>obj: projection*</li>
<li>v: Matrix[2]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_get_viewOffset</b></td><td>Getter for VrStereoConfig->viewOffset</td><td>Matrix[2]</td><td><ul><li>obj: viewOffset*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_viewOffset</b></td><td>Setter for VrStereoConfig->viewOffset</td><td>void</td><td><ul><li>obj: viewOffset*</li>
<li>v: Matrix[2]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_get_leftLensCenter</b></td><td>Getter for VrStereoConfig->leftLensCenter</td><td>float[2]</td><td><ul><li>obj: leftLensCenter*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_leftLensCenter</b></td><td>Setter for VrStereoConfig->leftLensCenter</td><td>void</td><td><ul><li>obj: leftLensCenter*</li>
<li>v: float[2]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_get_rightLensCenter</b></td><td>Getter for VrStereoConfig->rightLensCenter</td><td>float[2]</td><td><ul><li>obj: rightLensCenter*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_rightLensCenter</b></td><td>Setter for VrStereoConfig->rightLensCenter</td><td>void</td><td><ul><li>obj: rightLensCenter*</li>
<li>v: float[2]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_get_leftScreenCenter</b></td><td>Getter for VrStereoConfig->leftScreenCenter</td><td>float[2]</td><td><ul><li>obj: leftScreenCenter*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_leftScreenCenter</b></td><td>Setter for VrStereoConfig->leftScreenCenter</td><td>void</td><td><ul><li>obj: leftScreenCenter*</li>
<li>v: float[2]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_get_rightScreenCenter</b></td><td>Getter for VrStereoConfig->rightScreenCenter</td><td>float[2]</td><td><ul><li>obj: rightScreenCenter*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_rightScreenCenter</b></td><td>Setter for VrStereoConfig->rightScreenCenter</td><td>void</td><td><ul><li>obj: rightScreenCenter*</li>
<li>v: float[2]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_get_scale</b></td><td>Getter for VrStereoConfig->scale</td><td>float[2]</td><td><ul><li>obj: scale*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_scale</b></td><td>Setter for VrStereoConfig->scale</td><td>void</td><td><ul><li>obj: scale*</li>
<li>v: float[2]</li></ul></td></tr>
<tr><td><b>VrStereoConfig_get_scaleIn</b></td><td>Getter for VrStereoConfig->scaleIn</td><td>float[2]</td><td><ul><li>obj: scaleIn*</li></ul></td></tr>
<tr><td><b>VrStereoConfig_set_scaleIn</b></td><td>Setter for VrStereoConfig->scaleIn</td><td>void</td><td><ul><li>obj: scaleIn*</li>
<li>v: float[2]</li></ul></td></tr>
<tr><td><b>FilePathList_size</b></td><td>Get byte-size of FilePathList struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>FilePathList_get_capacity</b></td><td>Getter for FilePathList->capacity</td><td>unsigned int</td><td><ul><li>obj: capacity*</li></ul></td></tr>
<tr><td><b>FilePathList_set_capacity</b></td><td>Setter for FilePathList->capacity</td><td>void</td><td><ul><li>obj: capacity*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>FilePathList_get_count</b></td><td>Getter for FilePathList->count</td><td>unsigned int</td><td><ul><li>obj: count*</li></ul></td></tr>
<tr><td><b>FilePathList_set_count</b></td><td>Setter for FilePathList->count</td><td>void</td><td><ul><li>obj: count*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>FilePathList_get_paths</b></td><td>Getter for FilePathList->paths</td><td>char **</td><td><ul><li>obj: paths*</li></ul></td></tr>
<tr><td><b>FilePathList_set_paths</b></td><td>Setter for FilePathList->paths</td><td>void</td><td><ul><li>obj: paths*</li>
<li>v: char **</li></ul></td></tr>
<tr><td><b>AutomationEvent_size</b></td><td>Get byte-size of AutomationEvent struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>AutomationEvent_get_frame</b></td><td>Getter for AutomationEvent->frame</td><td>unsigned int</td><td><ul><li>obj: frame*</li></ul></td></tr>
<tr><td><b>AutomationEvent_set_frame</b></td><td>Setter for AutomationEvent->frame</td><td>void</td><td><ul><li>obj: frame*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>AutomationEvent_get_type</b></td><td>Getter for AutomationEvent->type</td><td>unsigned int</td><td><ul><li>obj: type*</li></ul></td></tr>
<tr><td><b>AutomationEvent_set_type</b></td><td>Setter for AutomationEvent->type</td><td>void</td><td><ul><li>obj: type*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>AutomationEvent_get_params</b></td><td>Getter for AutomationEvent->params</td><td>int[4]</td><td><ul><li>obj: params*</li></ul></td></tr>
<tr><td><b>AutomationEvent_set_params</b></td><td>Setter for AutomationEvent->params</td><td>void</td><td><ul><li>obj: params*</li>
<li>v: int[4]</li></ul></td></tr>
<tr><td><b>AutomationEventList_size</b></td><td>Get byte-size of AutomationEventList struct</td><td>unsigned int</td><td><ul></ul></td></tr>
<tr><td><b>AutomationEventList_get_capacity</b></td><td>Getter for AutomationEventList->capacity</td><td>unsigned int</td><td><ul><li>obj: capacity*</li></ul></td></tr>
<tr><td><b>AutomationEventList_set_capacity</b></td><td>Setter for AutomationEventList->capacity</td><td>void</td><td><ul><li>obj: capacity*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>AutomationEventList_get_count</b></td><td>Getter for AutomationEventList->count</td><td>unsigned int</td><td><ul><li>obj: count*</li></ul></td></tr>
<tr><td><b>AutomationEventList_set_count</b></td><td>Setter for AutomationEventList->count</td><td>void</td><td><ul><li>obj: count*</li>
<li>v: unsigned int</li></ul></td></tr>
<tr><td><b>AutomationEventList_get_events</b></td><td>Getter for AutomationEventList->events</td><td>AutomationEvent *</td><td><ul><li>obj: events*</li></ul></td></tr>
<tr><td><b>AutomationEventList_set_events</b></td><td>Setter for AutomationEventList->events</td><td>void</td><td><ul><li>obj: events*</li>
<li>v: AutomationEvent *</li></ul></td></tr>
</table>
  <br>

<h2 id=defines><a href="#top">defines</a></h2>
<table>
	<tr><th>name</th><th>type</th><th>value</th><th>description</th></tr>
	<tr><td><b>RAYLIB_H</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>RAYLIB_VERSION_MAJOR</b></td><td>INT</td><td>5</td><td></td></tr>
<tr><td><b>RAYLIB_VERSION_MINOR</b></td><td>INT</td><td>0</td><td></td></tr>
<tr><td><b>RAYLIB_VERSION_PATCH</b></td><td>INT</td><td>0</td><td></td></tr>
<tr><td><b>RAYLIB_VERSION</b></td><td>STRING</td><td>5.0</td><td></td></tr>
<tr><td><b>__declspec(x)</b></td><td>MACRO</td><td>__attribute__((x))</td><td></td></tr>
<tr><td><b>RLAPI</b></td><td>UNKNOWN</td><td>__declspec(dllexport)</td><td>We are building the library as a Win32 shared library (.dll)</td></tr>
<tr><td><b>PI</b></td><td>FLOAT</td><td>3.141592653589793</td><td></td></tr>
<tr><td><b>DEG2RAD</b></td><td>FLOAT_MATH</td><td>(PI/180.0f)</td><td></td></tr>
<tr><td><b>RAD2DEG</b></td><td>FLOAT_MATH</td><td>(180.0f/PI)</td><td></td></tr>
<tr><td><b>RL_MALLOC(sz)</b></td><td>MACRO</td><td>malloc(sz)</td><td></td></tr>
<tr><td><b>RL_CALLOC(n,sz)</b></td><td>MACRO</td><td>calloc(n,sz)</td><td></td></tr>
<tr><td><b>RL_REALLOC(ptr,sz)</b></td><td>MACRO</td><td>realloc(ptr,sz)</td><td></td></tr>
<tr><td><b>RL_FREE(ptr)</b></td><td>MACRO</td><td>free(ptr)</td><td></td></tr>
<tr><td><b>CLITERAL(type)</b></td><td>MACRO</td><td>type</td><td></td></tr>
<tr><td><b>RL_COLOR_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>RL_RECTANGLE_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>RL_VECTOR2_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>RL_VECTOR3_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>RL_VECTOR4_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>RL_QUATERNION_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>RL_MATRIX_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>LIGHTGRAY</b></td><td>COLOR</td><td>CLITERAL(Color){ 200, 200, 200, 255 }</td><td>Light Gray</td></tr>
<tr><td><b>GRAY</b></td><td>COLOR</td><td>CLITERAL(Color){ 130, 130, 130, 255 }</td><td>Gray</td></tr>
<tr><td><b>DARKGRAY</b></td><td>COLOR</td><td>CLITERAL(Color){ 80, 80, 80, 255 }</td><td>Dark Gray</td></tr>
<tr><td><b>YELLOW</b></td><td>COLOR</td><td>CLITERAL(Color){ 253, 249, 0, 255 }</td><td>Yellow</td></tr>
<tr><td><b>GOLD</b></td><td>COLOR</td><td>CLITERAL(Color){ 255, 203, 0, 255 }</td><td>Gold</td></tr>
<tr><td><b>ORANGE</b></td><td>COLOR</td><td>CLITERAL(Color){ 255, 161, 0, 255 }</td><td>Orange</td></tr>
<tr><td><b>PINK</b></td><td>COLOR</td><td>CLITERAL(Color){ 255, 109, 194, 255 }</td><td>Pink</td></tr>
<tr><td><b>RED</b></td><td>COLOR</td><td>CLITERAL(Color){ 230, 41, 55, 255 }</td><td>Red</td></tr>
<tr><td><b>MAROON</b></td><td>COLOR</td><td>CLITERAL(Color){ 190, 33, 55, 255 }</td><td>Maroon</td></tr>
<tr><td><b>GREEN</b></td><td>COLOR</td><td>CLITERAL(Color){ 0, 228, 48, 255 }</td><td>Green</td></tr>
<tr><td><b>LIME</b></td><td>COLOR</td><td>CLITERAL(Color){ 0, 158, 47, 255 }</td><td>Lime</td></tr>
<tr><td><b>DARKGREEN</b></td><td>COLOR</td><td>CLITERAL(Color){ 0, 117, 44, 255 }</td><td>Dark Green</td></tr>
<tr><td><b>SKYBLUE</b></td><td>COLOR</td><td>CLITERAL(Color){ 102, 191, 255, 255 }</td><td>Sky Blue</td></tr>
<tr><td><b>BLUE</b></td><td>COLOR</td><td>CLITERAL(Color){ 0, 121, 241, 255 }</td><td>Blue</td></tr>
<tr><td><b>DARKBLUE</b></td><td>COLOR</td><td>CLITERAL(Color){ 0, 82, 172, 255 }</td><td>Dark Blue</td></tr>
<tr><td><b>PURPLE</b></td><td>COLOR</td><td>CLITERAL(Color){ 200, 122, 255, 255 }</td><td>Purple</td></tr>
<tr><td><b>VIOLET</b></td><td>COLOR</td><td>CLITERAL(Color){ 135, 60, 190, 255 }</td><td>Violet</td></tr>
<tr><td><b>DARKPURPLE</b></td><td>COLOR</td><td>CLITERAL(Color){ 112, 31, 126, 255 }</td><td>Dark Purple</td></tr>
<tr><td><b>BEIGE</b></td><td>COLOR</td><td>CLITERAL(Color){ 211, 176, 131, 255 }</td><td>Beige</td></tr>
<tr><td><b>BROWN</b></td><td>COLOR</td><td>CLITERAL(Color){ 127, 106, 79, 255 }</td><td>Brown</td></tr>
<tr><td><b>DARKBROWN</b></td><td>COLOR</td><td>CLITERAL(Color){ 76, 63, 47, 255 }</td><td>Dark Brown</td></tr>
<tr><td><b>WHITE</b></td><td>COLOR</td><td>CLITERAL(Color){ 255, 255, 255, 255 }</td><td>White</td></tr>
<tr><td><b>BLACK</b></td><td>COLOR</td><td>CLITERAL(Color){ 0, 0, 0, 255 }</td><td>Black</td></tr>
<tr><td><b>BLANK</b></td><td>COLOR</td><td>CLITERAL(Color){ 0, 0, 0, 0 }</td><td>Blank (Transparent)</td></tr>
<tr><td><b>MAGENTA</b></td><td>COLOR</td><td>CLITERAL(Color){ 255, 0, 255, 255 }</td><td>Magenta</td></tr>
<tr><td><b>RAYWHITE</b></td><td>COLOR</td><td>CLITERAL(Color){ 245, 245, 245, 255 }</td><td>My own White (raylib logo)</td></tr>
<tr><td><b>RL_BOOL_TYPE</b></td><td>GUARD</td><td></td><td></td></tr>
<tr><td><b>MOUSE_LEFT_BUTTON</b></td><td>UNKNOWN</td><td>MOUSE_BUTTON_LEFT</td><td></td></tr>
<tr><td><b>MOUSE_RIGHT_BUTTON</b></td><td>UNKNOWN</td><td>MOUSE_BUTTON_RIGHT</td><td></td></tr>
<tr><td><b>MOUSE_MIDDLE_BUTTON</b></td><td>UNKNOWN</td><td>MOUSE_BUTTON_MIDDLE</td><td></td></tr>
<tr><td><b>MATERIAL_MAP_DIFFUSE</b></td><td>UNKNOWN</td><td>MATERIAL_MAP_ALBEDO</td><td></td></tr>
<tr><td><b>MATERIAL_MAP_SPECULAR</b></td><td>UNKNOWN</td><td>MATERIAL_MAP_METALNESS</td><td></td></tr>
<tr><td><b>SHADER_LOC_MAP_DIFFUSE</b></td><td>UNKNOWN</td><td>SHADER_LOC_MAP_ALBEDO</td><td></td></tr>
<tr><td><b>SHADER_LOC_MAP_SPECULAR</b></td><td>UNKNOWN</td><td>SHADER_LOC_MAP_METALNESS</td><td></td></tr>
</table>
  <br>

<h2 id=structs><a href="#top">structs</a></h2>
<table>
	<tr><th>name</th><th>description</th><th>fields</th></tr>
	<tr><td><b>Vector2</b></td><td>Vector2, 2 components</td><td><ul><li title="Vector x component">x: float</li>
<li title="Vector y component">y: float</li></ul></td></tr>
<tr><td><b>Vector3</b></td><td>Vector3, 3 components</td><td><ul><li title="Vector x component">x: float</li>
<li title="Vector y component">y: float</li>
<li title="Vector z component">z: float</li></ul></td></tr>
<tr><td><b>Vector4</b></td><td>Vector4, 4 components</td><td><ul><li title="Vector x component">x: float</li>
<li title="Vector y component">y: float</li>
<li title="Vector z component">z: float</li>
<li title="Vector w component">w: float</li></ul></td></tr>
<tr><td><b>Matrix</b></td><td>Matrix, 4x4 components, column major, OpenGL style, right-handed</td><td><ul><li title="Matrix first row (4 components)">m0: float</li>
<li title="Matrix first row (4 components)">m4: float</li>
<li title="Matrix first row (4 components)">m8: float</li>
<li title="Matrix first row (4 components)">m12: float</li>
<li title="Matrix second row (4 components)">m1: float</li>
<li title="Matrix second row (4 components)">m5: float</li>
<li title="Matrix second row (4 components)">m9: float</li>
<li title="Matrix second row (4 components)">m13: float</li>
<li title="Matrix third row (4 components)">m2: float</li>
<li title="Matrix third row (4 components)">m6: float</li>
<li title="Matrix third row (4 components)">m10: float</li>
<li title="Matrix third row (4 components)">m14: float</li>
<li title="Matrix fourth row (4 components)">m3: float</li>
<li title="Matrix fourth row (4 components)">m7: float</li>
<li title="Matrix fourth row (4 components)">m11: float</li>
<li title="Matrix fourth row (4 components)">m15: float</li></ul></td></tr>
<tr><td><b>Color</b></td><td>Color, 4 components, R8G8B8A8 (32bit)</td><td><ul><li title="Color red value">r: unsigned char</li>
<li title="Color green value">g: unsigned char</li>
<li title="Color blue value">b: unsigned char</li>
<li title="Color alpha value">a: unsigned char</li></ul></td></tr>
<tr><td><b>Rectangle</b></td><td>Rectangle, 4 components</td><td><ul><li title="Rectangle top-left corner position x">x: float</li>
<li title="Rectangle top-left corner position y">y: float</li>
<li title="Rectangle width">width: float</li>
<li title="Rectangle height">height: float</li></ul></td></tr>
<tr><td><b>Image</b></td><td>Image, pixel data stored in CPU memory (RAM)</td><td><ul><li title="Image raw data">data: void *</li>
<li title="Image base width">width: int</li>
<li title="Image base height">height: int</li>
<li title="Mipmap levels, 1 by default">mipmaps: int</li>
<li title="Data format (PixelFormat type)">format: int</li></ul></td></tr>
<tr><td><b>Texture</b></td><td>Texture, tex data stored in GPU memory (VRAM)</td><td><ul><li title="OpenGL texture id">id: unsigned int</li>
<li title="Texture base width">width: int</li>
<li title="Texture base height">height: int</li>
<li title="Mipmap levels, 1 by default">mipmaps: int</li>
<li title="Data format (PixelFormat type)">format: int</li></ul></td></tr>
<tr><td><b>RenderTexture</b></td><td>RenderTexture, fbo for texture rendering</td><td><ul><li title="OpenGL framebuffer object id">id: unsigned int</li>
<li title="Color buffer attachment texture">texture: Texture</li>
<li title="Depth buffer attachment texture">depth: Texture</li></ul></td></tr>
<tr><td><b>NPatchInfo</b></td><td>NPatchInfo, n-patch layout info</td><td><ul><li title="Texture source rectangle">source: Rectangle</li>
<li title="Left border offset">left: int</li>
<li title="Top border offset">top: int</li>
<li title="Right border offset">right: int</li>
<li title="Bottom border offset">bottom: int</li>
<li title="Layout of the n-patch: 3x3, 1x3 or 3x1">layout: int</li></ul></td></tr>
<tr><td><b>GlyphInfo</b></td><td>GlyphInfo, font characters glyphs info</td><td><ul><li title="Character value (Unicode)">value: int</li>
<li title="Character offset X when drawing">offsetX: int</li>
<li title="Character offset Y when drawing">offsetY: int</li>
<li title="Character advance position X">advanceX: int</li>
<li title="Character image data">image: Image</li></ul></td></tr>
<tr><td><b>Font</b></td><td>Font, font texture and GlyphInfo array data</td><td><ul><li title="Base size (default chars height)">baseSize: int</li>
<li title="Number of glyph characters">glyphCount: int</li>
<li title="Padding around the glyph characters">glyphPadding: int</li>
<li title="Texture atlas containing the glyphs">texture: Texture2D</li>
<li title="Rectangles in texture for the glyphs">recs: Rectangle *</li>
<li title="Glyphs info data">glyphs: GlyphInfo *</li></ul></td></tr>
<tr><td><b>Camera3D</b></td><td>Camera, defines position/orientation in 3d space</td><td><ul><li title="Camera position">position: Vector3</li>
<li title="Camera target it looks-at">target: Vector3</li>
<li title="Camera up vector (rotation over its axis)">up: Vector3</li>
<li title="Camera field-of-view aperture in Y (degrees) in perspective, used as near plane width in orthographic">fovy: float</li>
<li title="Camera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC">projection: int</li></ul></td></tr>
<tr><td><b>Camera2D</b></td><td>Camera2D, defines position/orientation in 2d space</td><td><ul><li title="Camera offset (displacement from target)">offset: Vector2</li>
<li title="Camera target (rotation and zoom origin)">target: Vector2</li>
<li title="Camera rotation in degrees">rotation: float</li>
<li title="Camera zoom (scaling), should be 1.0f by default">zoom: float</li></ul></td></tr>
<tr><td><b>Mesh</b></td><td>Mesh, vertex data and vao/vbo</td><td><ul><li title="Number of vertices stored in arrays">vertexCount: int</li>
<li title="Number of triangles stored (indexed or not)">triangleCount: int</li>
<li title="Vertex position (XYZ - 3 components per vertex) (shader-location = 0)">vertices: float *</li>
<li title="Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)">texcoords: float *</li>
<li title="Vertex texture second coordinates (UV - 2 components per vertex) (shader-location = 5)">texcoords2: float *</li>
<li title="Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)">normals: float *</li>
<li title="Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)">tangents: float *</li>
<li title="Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)">colors: unsigned char *</li>
<li title="Vertex indices (in case vertex data comes indexed)">indices: unsigned short *</li>
<li title="Animated vertex positions (after bones transformations)">animVertices: float *</li>
<li title="Animated normals (after bones transformations)">animNormals: float *</li>
<li title="Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)">boneIds: unsigned char *</li>
<li title="Vertex bone weight, up to 4 bones influence by vertex (skinning)">boneWeights: float *</li>
<li title="OpenGL Vertex Array Object id">vaoId: unsigned int</li>
<li title="OpenGL Vertex Buffer Objects id (default vertex data)">vboId: unsigned int *</li></ul></td></tr>
<tr><td><b>Shader</b></td><td>Shader</td><td><ul><li title="Shader program id">id: unsigned int</li>
<li title="Shader locations array (RL_MAX_SHADER_LOCATIONS)">locs: int *</li></ul></td></tr>
<tr><td><b>MaterialMap</b></td><td>MaterialMap</td><td><ul><li title="Material map texture">texture: Texture2D</li>
<li title="Material map color">color: Color</li>
<li title="Material map value">value: float</li></ul></td></tr>
<tr><td><b>Material</b></td><td>Material, includes shader and maps</td><td><ul><li title="Material shader">shader: Shader</li>
<li title="Material maps array (MAX_MATERIAL_MAPS)">maps: MaterialMap *</li>
<li title="Material generic parameters (if required)">params: float[4]</li></ul></td></tr>
<tr><td><b>Transform</b></td><td>Transform, vertex transformation data</td><td><ul><li title="Translation">translation: Vector3</li>
<li title="Rotation">rotation: Quaternion</li>
<li title="Scale">scale: Vector3</li></ul></td></tr>
<tr><td><b>BoneInfo</b></td><td>Bone, skeletal animation bone</td><td><ul><li title="Bone name">name: char[32]</li>
<li title="Bone parent">parent: int</li></ul></td></tr>
<tr><td><b>Model</b></td><td>Model, meshes, materials and animation data</td><td><ul><li title="Local transform matrix">transform: Matrix</li>
<li title="Number of meshes">meshCount: int</li>
<li title="Number of materials">materialCount: int</li>
<li title="Meshes array">meshes: Mesh *</li>
<li title="Materials array">materials: Material *</li>
<li title="Mesh material number">meshMaterial: int *</li>
<li title="Number of bones">boneCount: int</li>
<li title="Bones information (skeleton)">bones: BoneInfo *</li>
<li title="Bones base transformation (pose)">bindPose: Transform *</li></ul></td></tr>
<tr><td><b>ModelAnimation</b></td><td>ModelAnimation</td><td><ul><li title="Number of bones">boneCount: int</li>
<li title="Number of animation frames">frameCount: int</li>
<li title="Bones information (skeleton)">bones: BoneInfo *</li>
<li title="Poses array by frame">framePoses: Transform **</li>
<li title="Animation name">name: char[32]</li></ul></td></tr>
<tr><td><b>Ray</b></td><td>Ray, ray for raycasting</td><td><ul><li title="Ray position (origin)">position: Vector3</li>
<li title="Ray direction">direction: Vector3</li></ul></td></tr>
<tr><td><b>RayCollision</b></td><td>RayCollision, ray hit information</td><td><ul><li title="Did the ray hit something?">hit: bool</li>
<li title="Distance to the nearest hit">distance: float</li>
<li title="Point of the nearest hit">point: Vector3</li>
<li title="Surface normal of hit">normal: Vector3</li></ul></td></tr>
<tr><td><b>BoundingBox</b></td><td>BoundingBox</td><td><ul><li title="Minimum vertex box-corner">min: Vector3</li>
<li title="Maximum vertex box-corner">max: Vector3</li></ul></td></tr>
<tr><td><b>Wave</b></td><td>Wave, audio wave data</td><td><ul><li title="Total number of frames (considering channels)">frameCount: unsigned int</li>
<li title="Frequency (samples per second)">sampleRate: unsigned int</li>
<li title="Bit depth (bits per sample): 8, 16, 32 (24 not supported)">sampleSize: unsigned int</li>
<li title="Number of channels (1-mono, 2-stereo, ...)">channels: unsigned int</li>
<li title="Buffer data pointer">data: void *</li></ul></td></tr>
<tr><td><b>AudioStream</b></td><td>AudioStream, custom audio stream</td><td><ul><li title="Pointer to internal data used by the audio system">buffer: rAudioBuffer *</li>
<li title="Pointer to internal data processor, useful for audio effects">processor: rAudioProcessor *</li>
<li title="Frequency (samples per second)">sampleRate: unsigned int</li>
<li title="Bit depth (bits per sample): 8, 16, 32 (24 not supported)">sampleSize: unsigned int</li>
<li title="Number of channels (1-mono, 2-stereo, ...)">channels: unsigned int</li></ul></td></tr>
<tr><td><b>Sound</b></td><td>Sound</td><td><ul><li title="Audio stream">stream: AudioStream</li>
<li title="Total number of frames (considering channels)">frameCount: unsigned int</li></ul></td></tr>
<tr><td><b>Music</b></td><td>Music, audio stream, anything longer than ~10 seconds should be streamed</td><td><ul><li title="Audio stream">stream: AudioStream</li>
<li title="Total number of frames (considering channels)">frameCount: unsigned int</li>
<li title="Music looping enable">looping: bool</li>
<li title="Type of music context (audio filetype)">ctxType: int</li>
<li title="Audio context data, depends on type">ctxData: void *</li></ul></td></tr>
<tr><td><b>VrDeviceInfo</b></td><td>VrDeviceInfo, Head-Mounted-Display device parameters</td><td><ul><li title="Horizontal resolution in pixels">hResolution: int</li>
<li title="Vertical resolution in pixels">vResolution: int</li>
<li title="Horizontal size in meters">hScreenSize: float</li>
<li title="Vertical size in meters">vScreenSize: float</li>
<li title="Screen center in meters">vScreenCenter: float</li>
<li title="Distance between eye and display in meters">eyeToScreenDistance: float</li>
<li title="Lens separation distance in meters">lensSeparationDistance: float</li>
<li title="IPD (distance between pupils) in meters">interpupillaryDistance: float</li>
<li title="Lens distortion constant parameters">lensDistortionValues: float[4]</li>
<li title="Chromatic aberration correction parameters">chromaAbCorrection: float[4]</li></ul></td></tr>
<tr><td><b>VrStereoConfig</b></td><td>VrStereoConfig, VR stereo rendering configuration for simulator</td><td><ul><li title="VR projection matrices (per eye)">projection: Matrix[2]</li>
<li title="VR view offset matrices (per eye)">viewOffset: Matrix[2]</li>
<li title="VR left lens center">leftLensCenter: float[2]</li>
<li title="VR right lens center">rightLensCenter: float[2]</li>
<li title="VR left screen center">leftScreenCenter: float[2]</li>
<li title="VR right screen center">rightScreenCenter: float[2]</li>
<li title="VR distortion scale">scale: float[2]</li>
<li title="VR distortion scale in">scaleIn: float[2]</li></ul></td></tr>
<tr><td><b>FilePathList</b></td><td>File path list</td><td><ul><li title="Filepaths max entries">capacity: unsigned int</li>
<li title="Filepaths entries count">count: unsigned int</li>
<li title="Filepaths entries">paths: char **</li></ul></td></tr>
<tr><td><b>AutomationEvent</b></td><td>Automation event</td><td><ul><li title="Event frame">frame: unsigned int</li>
<li title="Event type (AutomationEventType)">type: unsigned int</li>
<li title="Event parameters (if required)">params: int[4]</li></ul></td></tr>
<tr><td><b>AutomationEventList</b></td><td>Automation event list</td><td><ul><li title="Events max entries (MAX_AUTOMATION_EVENTS)">capacity: unsigned int</li>
<li title="Events entries count">count: unsigned int</li>
<li title="Events entries">events: AutomationEvent *</li></ul></td></tr>
</table>
  <br>

<h2 id=aliases><a href="#top">aliases</a></h2>
<table>
	<tr><th>type</th><th>name</th><th>description</th></tr>
	<tr><td>Vector4</td><td><b>Quaternion</b></td><td>Quaternion, 4 components (Vector4 alias)</td></tr>
<tr><td>Texture</td><td><b>Texture2D</b></td><td>Texture2D, same as Texture</td></tr>
<tr><td>Texture</td><td><b>TextureCubemap</b></td><td>TextureCubemap, same as Texture</td></tr>
<tr><td>RenderTexture</td><td><b>RenderTexture2D</b></td><td>RenderTexture2D, same as RenderTexture</td></tr>
<tr><td>Camera3D</td><td><b>Camera</b></td><td>Camera type fallback, defaults to Camera3D</td></tr>
</table>
  <br>

<h2 id=enums><a href="#top">enums</a></h2>
<table>
	<tr><th>name</th><th>description</th><th>values</th></tr>
	<tr><td><b>ConfigFlags</b></td><td>System/Window config flags</td><td><ul><li title="Set to try enabling V-Sync on GPU">FLAG_VSYNC_HINT = 64</li>
<li title="Set to run program in fullscreen">FLAG_FULLSCREEN_MODE = 2</li>
<li title="Set to allow resizable window">FLAG_WINDOW_RESIZABLE = 4</li>
<li title="Set to disable window decoration (frame and buttons)">FLAG_WINDOW_UNDECORATED = 8</li>
<li title="Set to hide window">FLAG_WINDOW_HIDDEN = 128</li>
<li title="Set to minimize window (iconify)">FLAG_WINDOW_MINIMIZED = 512</li>
<li title="Set to maximize window (expanded to monitor)">FLAG_WINDOW_MAXIMIZED = 1024</li>
<li title="Set to window non focused">FLAG_WINDOW_UNFOCUSED = 2048</li>
<li title="Set to window always on top">FLAG_WINDOW_TOPMOST = 4096</li>
<li title="Set to allow windows running while minimized">FLAG_WINDOW_ALWAYS_RUN = 256</li>
<li title="Set to allow transparent framebuffer">FLAG_WINDOW_TRANSPARENT = 16</li>
<li title="Set to support HighDPI">FLAG_WINDOW_HIGHDPI = 8192</li>
<li title="Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED">FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384</li>
<li title="Set to run program in borderless windowed mode">FLAG_BORDERLESS_WINDOWED_MODE = 32768</li>
<li title="Set to try enabling MSAA 4X">FLAG_MSAA_4X_HINT = 32</li>
<li title="Set to try enabling interlaced video format (for V3D)">FLAG_INTERLACED_HINT = 65536</li></ul></td></tr>
<tr><td><b>TraceLogLevel</b></td><td>Trace log level</td><td><ul><li title="Display all logs">LOG_ALL</li>
<li title="Trace logging, intended for internal use only">LOG_TRACE = 1</li>
<li title="Debug logging, used for internal debugging, it should be disabled on release builds">LOG_DEBUG = 2</li>
<li title="Info logging, used for program execution info">LOG_INFO = 3</li>
<li title="Warning logging, used on recoverable failures">LOG_WARNING = 4</li>
<li title="Error logging, used on unrecoverable failures">LOG_ERROR = 5</li>
<li title="Fatal logging, used to abort program: exit(EXIT_FAILURE)">LOG_FATAL = 6</li>
<li title="Disable logging">LOG_NONE = 7</li></ul></td></tr>
<tr><td><b>KeyboardKey</b></td><td>Keyboard keys (US keyboard layout)</td><td><ul><li title="Key: NULL, used for no key pressed">KEY_NULL</li>
<li title="Key: '">KEY_APOSTROPHE = 39</li>
<li title="Key: ,">KEY_COMMA = 44</li>
<li title="Key: -">KEY_MINUS = 45</li>
<li title="Key: .">KEY_PERIOD = 46</li>
<li title="Key: /">KEY_SLASH = 47</li>
<li title="Key: 0">KEY_ZERO = 48</li>
<li title="Key: 1">KEY_ONE = 49</li>
<li title="Key: 2">KEY_TWO = 50</li>
<li title="Key: 3">KEY_THREE = 51</li>
<li title="Key: 4">KEY_FOUR = 52</li>
<li title="Key: 5">KEY_FIVE = 53</li>
<li title="Key: 6">KEY_SIX = 54</li>
<li title="Key: 7">KEY_SEVEN = 55</li>
<li title="Key: 8">KEY_EIGHT = 56</li>
<li title="Key: 9">KEY_NINE = 57</li>
<li title="Key: ;">KEY_SEMICOLON = 59</li>
<li title="Key: =">KEY_EQUAL = 61</li>
<li title="Key: A | a">KEY_A = 65</li>
<li title="Key: B | b">KEY_B = 66</li>
<li title="Key: C | c">KEY_C = 67</li>
<li title="Key: D | d">KEY_D = 68</li>
<li title="Key: E | e">KEY_E = 69</li>
<li title="Key: F | f">KEY_F = 70</li>
<li title="Key: G | g">KEY_G = 71</li>
<li title="Key: H | h">KEY_H = 72</li>
<li title="Key: I | i">KEY_I = 73</li>
<li title="Key: J | j">KEY_J = 74</li>
<li title="Key: K | k">KEY_K = 75</li>
<li title="Key: L | l">KEY_L = 76</li>
<li title="Key: M | m">KEY_M = 77</li>
<li title="Key: N | n">KEY_N = 78</li>
<li title="Key: O | o">KEY_O = 79</li>
<li title="Key: P | p">KEY_P = 80</li>
<li title="Key: Q | q">KEY_Q = 81</li>
<li title="Key: R | r">KEY_R = 82</li>
<li title="Key: S | s">KEY_S = 83</li>
<li title="Key: T | t">KEY_T = 84</li>
<li title="Key: U | u">KEY_U = 85</li>
<li title="Key: V | v">KEY_V = 86</li>
<li title="Key: W | w">KEY_W = 87</li>
<li title="Key: X | x">KEY_X = 88</li>
<li title="Key: Y | y">KEY_Y = 89</li>
<li title="Key: Z | z">KEY_Z = 90</li>
<li title="Key: [">KEY_LEFT_BRACKET = 91</li>
<li title="Key: '\'">KEY_BACKSLASH = 92</li>
<li title="Key: ]">KEY_RIGHT_BRACKET = 93</li>
<li title="Key: `">KEY_GRAVE = 96</li>
<li title="Key: Space">KEY_SPACE = 32</li>
<li title="Key: Esc">KEY_ESCAPE = 256</li>
<li title="Key: Enter">KEY_ENTER = 257</li>
<li title="Key: Tab">KEY_TAB = 258</li>
<li title="Key: Backspace">KEY_BACKSPACE = 259</li>
<li title="Key: Ins">KEY_INSERT = 260</li>
<li title="Key: Del">KEY_DELETE = 261</li>
<li title="Key: Cursor right">KEY_RIGHT = 262</li>
<li title="Key: Cursor left">KEY_LEFT = 263</li>
<li title="Key: Cursor down">KEY_DOWN = 264</li>
<li title="Key: Cursor up">KEY_UP = 265</li>
<li title="Key: Page up">KEY_PAGE_UP = 266</li>
<li title="Key: Page down">KEY_PAGE_DOWN = 267</li>
<li title="Key: Home">KEY_HOME = 268</li>
<li title="Key: End">KEY_END = 269</li>
<li title="Key: Caps lock">KEY_CAPS_LOCK = 280</li>
<li title="Key: Scroll down">KEY_SCROLL_LOCK = 281</li>
<li title="Key: Num lock">KEY_NUM_LOCK = 282</li>
<li title="Key: Print screen">KEY_PRINT_SCREEN = 283</li>
<li title="Key: Pause">KEY_PAUSE = 284</li>
<li title="Key: F1">KEY_F1 = 290</li>
<li title="Key: F2">KEY_F2 = 291</li>
<li title="Key: F3">KEY_F3 = 292</li>
<li title="Key: F4">KEY_F4 = 293</li>
<li title="Key: F5">KEY_F5 = 294</li>
<li title="Key: F6">KEY_F6 = 295</li>
<li title="Key: F7">KEY_F7 = 296</li>
<li title="Key: F8">KEY_F8 = 297</li>
<li title="Key: F9">KEY_F9 = 298</li>
<li title="Key: F10">KEY_F10 = 299</li>
<li title="Key: F11">KEY_F11 = 300</li>
<li title="Key: F12">KEY_F12 = 301</li>
<li title="Key: Shift left">KEY_LEFT_SHIFT = 340</li>
<li title="Key: Control left">KEY_LEFT_CONTROL = 341</li>
<li title="Key: Alt left">KEY_LEFT_ALT = 342</li>
<li title="Key: Super left">KEY_LEFT_SUPER = 343</li>
<li title="Key: Shift right">KEY_RIGHT_SHIFT = 344</li>
<li title="Key: Control right">KEY_RIGHT_CONTROL = 345</li>
<li title="Key: Alt right">KEY_RIGHT_ALT = 346</li>
<li title="Key: Super right">KEY_RIGHT_SUPER = 347</li>
<li title="Key: KB menu">KEY_KB_MENU = 348</li>
<li title="Key: Keypad 0">KEY_KP_0 = 320</li>
<li title="Key: Keypad 1">KEY_KP_1 = 321</li>
<li title="Key: Keypad 2">KEY_KP_2 = 322</li>
<li title="Key: Keypad 3">KEY_KP_3 = 323</li>
<li title="Key: Keypad 4">KEY_KP_4 = 324</li>
<li title="Key: Keypad 5">KEY_KP_5 = 325</li>
<li title="Key: Keypad 6">KEY_KP_6 = 326</li>
<li title="Key: Keypad 7">KEY_KP_7 = 327</li>
<li title="Key: Keypad 8">KEY_KP_8 = 328</li>
<li title="Key: Keypad 9">KEY_KP_9 = 329</li>
<li title="Key: Keypad .">KEY_KP_DECIMAL = 330</li>
<li title="Key: Keypad /">KEY_KP_DIVIDE = 331</li>
<li title="Key: Keypad *">KEY_KP_MULTIPLY = 332</li>
<li title="Key: Keypad -">KEY_KP_SUBTRACT = 333</li>
<li title="Key: Keypad +">KEY_KP_ADD = 334</li>
<li title="Key: Keypad Enter">KEY_KP_ENTER = 335</li>
<li title="Key: Keypad =">KEY_KP_EQUAL = 336</li>
<li title="Key: Android back button">KEY_BACK = 4</li>
<li title="Key: Android menu button">KEY_MENU = 82</li>
<li title="Key: Android volume up button">KEY_VOLUME_UP = 24</li>
<li title="Key: Android volume down button">KEY_VOLUME_DOWN = 25</li></ul></td></tr>
<tr><td><b>MouseButton</b></td><td>Mouse buttons</td><td><ul><li title="Mouse button left">MOUSE_BUTTON_LEFT</li>
<li title="Mouse button right">MOUSE_BUTTON_RIGHT = 1</li>
<li title="Mouse button middle (pressed wheel)">MOUSE_BUTTON_MIDDLE = 2</li>
<li title="Mouse button side (advanced mouse device)">MOUSE_BUTTON_SIDE = 3</li>
<li title="Mouse button extra (advanced mouse device)">MOUSE_BUTTON_EXTRA = 4</li>
<li title="Mouse button forward (advanced mouse device)">MOUSE_BUTTON_FORWARD = 5</li>
<li title="Mouse button back (advanced mouse device)">MOUSE_BUTTON_BACK = 6</li></ul></td></tr>
<tr><td><b>MouseCursor</b></td><td>Mouse cursor</td><td><ul><li title="Default pointer shape">MOUSE_CURSOR_DEFAULT</li>
<li title="Arrow shape">MOUSE_CURSOR_ARROW = 1</li>
<li title="Text writing cursor shape">MOUSE_CURSOR_IBEAM = 2</li>
<li title="Cross shape">MOUSE_CURSOR_CROSSHAIR = 3</li>
<li title="Pointing hand cursor">MOUSE_CURSOR_POINTING_HAND = 4</li>
<li title="Horizontal resize/move arrow shape">MOUSE_CURSOR_RESIZE_EW = 5</li>
<li title="Vertical resize/move arrow shape">MOUSE_CURSOR_RESIZE_NS = 6</li>
<li title="Top-left to bottom-right diagonal resize/move arrow shape">MOUSE_CURSOR_RESIZE_NWSE = 7</li>
<li title="The top-right to bottom-left diagonal resize/move arrow shape">MOUSE_CURSOR_RESIZE_NESW = 8</li>
<li title="The omnidirectional resize/move cursor shape">MOUSE_CURSOR_RESIZE_ALL = 9</li>
<li title="The operation-not-allowed shape">MOUSE_CURSOR_NOT_ALLOWED = 10</li></ul></td></tr>
<tr><td><b>GamepadButton</b></td><td>Gamepad buttons</td><td><ul><li title="Unknown button, just for error checking">GAMEPAD_BUTTON_UNKNOWN</li>
<li title="Gamepad left DPAD up button">GAMEPAD_BUTTON_LEFT_FACE_UP = 1</li>
<li title="Gamepad left DPAD right button">GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2</li>
<li title="Gamepad left DPAD down button">GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3</li>
<li title="Gamepad left DPAD left button">GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4</li>
<li title="Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)">GAMEPAD_BUTTON_RIGHT_FACE_UP = 5</li>
<li title="Gamepad right button right (i.e. PS3: Square, Xbox: X)">GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6</li>
<li title="Gamepad right button down (i.e. PS3: Cross, Xbox: A)">GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7</li>
<li title="Gamepad right button left (i.e. PS3: Circle, Xbox: B)">GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8</li>
<li title="Gamepad top/back trigger left (first), it could be a trailing button">GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9</li>
<li title="Gamepad top/back trigger left (second), it could be a trailing button">GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10</li>
<li title="Gamepad top/back trigger right (one), it could be a trailing button">GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11</li>
<li title="Gamepad top/back trigger right (second), it could be a trailing button">GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12</li>
<li title="Gamepad center buttons, left one (i.e. PS3: Select)">GAMEPAD_BUTTON_MIDDLE_LEFT = 13</li>
<li title="Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)">GAMEPAD_BUTTON_MIDDLE = 14</li>
<li title="Gamepad center buttons, right one (i.e. PS3: Start)">GAMEPAD_BUTTON_MIDDLE_RIGHT = 15</li>
<li title="Gamepad joystick pressed button left">GAMEPAD_BUTTON_LEFT_THUMB = 16</li>
<li title="Gamepad joystick pressed button right">GAMEPAD_BUTTON_RIGHT_THUMB = 17</li></ul></td></tr>
<tr><td><b>GamepadAxis</b></td><td>Gamepad axis</td><td><ul><li title="Gamepad left stick X axis">GAMEPAD_AXIS_LEFT_X</li>
<li title="Gamepad left stick Y axis">GAMEPAD_AXIS_LEFT_Y = 1</li>
<li title="Gamepad right stick X axis">GAMEPAD_AXIS_RIGHT_X = 2</li>
<li title="Gamepad right stick Y axis">GAMEPAD_AXIS_RIGHT_Y = 3</li>
<li title="Gamepad back trigger left, pressure level: [1..-1]">GAMEPAD_AXIS_LEFT_TRIGGER = 4</li>
<li title="Gamepad back trigger right, pressure level: [1..-1]">GAMEPAD_AXIS_RIGHT_TRIGGER = 5</li></ul></td></tr>
<tr><td><b>MaterialMapIndex</b></td><td>Material map index</td><td><ul><li title="Albedo material (same as: MATERIAL_MAP_DIFFUSE)">MATERIAL_MAP_ALBEDO</li>
<li title="Metalness material (same as: MATERIAL_MAP_SPECULAR)">MATERIAL_MAP_METALNESS = 1</li>
<li title="Normal material">MATERIAL_MAP_NORMAL = 2</li>
<li title="Roughness material">MATERIAL_MAP_ROUGHNESS = 3</li>
<li title="Ambient occlusion material">MATERIAL_MAP_OCCLUSION = 4</li>
<li title="Emission material">MATERIAL_MAP_EMISSION = 5</li>
<li title="Heightmap material">MATERIAL_MAP_HEIGHT = 6</li>
<li title="Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)">MATERIAL_MAP_CUBEMAP = 7</li>
<li title="Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)">MATERIAL_MAP_IRRADIANCE = 8</li>
<li title="Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)">MATERIAL_MAP_PREFILTER = 9</li>
<li title="Brdf material">MATERIAL_MAP_BRDF = 10</li></ul></td></tr>
<tr><td><b>ShaderLocationIndex</b></td><td>Shader location index</td><td><ul><li title="Shader location: vertex attribute: position">SHADER_LOC_VERTEX_POSITION</li>
<li title="Shader location: vertex attribute: texcoord01">SHADER_LOC_VERTEX_TEXCOORD01 = 1</li>
<li title="Shader location: vertex attribute: texcoord02">SHADER_LOC_VERTEX_TEXCOORD02 = 2</li>
<li title="Shader location: vertex attribute: normal">SHADER_LOC_VERTEX_NORMAL = 3</li>
<li title="Shader location: vertex attribute: tangent">SHADER_LOC_VERTEX_TANGENT = 4</li>
<li title="Shader location: vertex attribute: color">SHADER_LOC_VERTEX_COLOR = 5</li>
<li title="Shader location: matrix uniform: model-view-projection">SHADER_LOC_MATRIX_MVP = 6</li>
<li title="Shader location: matrix uniform: view (camera transform)">SHADER_LOC_MATRIX_VIEW = 7</li>
<li title="Shader location: matrix uniform: projection">SHADER_LOC_MATRIX_PROJECTION = 8</li>
<li title="Shader location: matrix uniform: model (transform)">SHADER_LOC_MATRIX_MODEL = 9</li>
<li title="Shader location: matrix uniform: normal">SHADER_LOC_MATRIX_NORMAL = 10</li>
<li title="Shader location: vector uniform: view">SHADER_LOC_VECTOR_VIEW = 11</li>
<li title="Shader location: vector uniform: diffuse color">SHADER_LOC_COLOR_DIFFUSE = 12</li>
<li title="Shader location: vector uniform: specular color">SHADER_LOC_COLOR_SPECULAR = 13</li>
<li title="Shader location: vector uniform: ambient color">SHADER_LOC_COLOR_AMBIENT = 14</li>
<li title="Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)">SHADER_LOC_MAP_ALBEDO = 15</li>
<li title="Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)">SHADER_LOC_MAP_METALNESS = 16</li>
<li title="Shader location: sampler2d texture: normal">SHADER_LOC_MAP_NORMAL = 17</li>
<li title="Shader location: sampler2d texture: roughness">SHADER_LOC_MAP_ROUGHNESS = 18</li>
<li title="Shader location: sampler2d texture: occlusion">SHADER_LOC_MAP_OCCLUSION = 19</li>
<li title="Shader location: sampler2d texture: emission">SHADER_LOC_MAP_EMISSION = 20</li>
<li title="Shader location: sampler2d texture: height">SHADER_LOC_MAP_HEIGHT = 21</li>
<li title="Shader location: samplerCube texture: cubemap">SHADER_LOC_MAP_CUBEMAP = 22</li>
<li title="Shader location: samplerCube texture: irradiance">SHADER_LOC_MAP_IRRADIANCE = 23</li>
<li title="Shader location: samplerCube texture: prefilter">SHADER_LOC_MAP_PREFILTER = 24</li>
<li title="Shader location: sampler2d texture: brdf">SHADER_LOC_MAP_BRDF = 25</li></ul></td></tr>
<tr><td><b>ShaderUniformDataType</b></td><td>Shader uniform data type</td><td><ul><li title="Shader uniform type: float">SHADER_UNIFORM_FLOAT</li>
<li title="Shader uniform type: vec2 (2 float)">SHADER_UNIFORM_VEC2 = 1</li>
<li title="Shader uniform type: vec3 (3 float)">SHADER_UNIFORM_VEC3 = 2</li>
<li title="Shader uniform type: vec4 (4 float)">SHADER_UNIFORM_VEC4 = 3</li>
<li title="Shader uniform type: int">SHADER_UNIFORM_INT = 4</li>
<li title="Shader uniform type: ivec2 (2 int)">SHADER_UNIFORM_IVEC2 = 5</li>
<li title="Shader uniform type: ivec3 (3 int)">SHADER_UNIFORM_IVEC3 = 6</li>
<li title="Shader uniform type: ivec4 (4 int)">SHADER_UNIFORM_IVEC4 = 7</li>
<li title="Shader uniform type: sampler2d">SHADER_UNIFORM_SAMPLER2D = 8</li></ul></td></tr>
<tr><td><b>ShaderAttributeDataType</b></td><td>Shader attribute data types</td><td><ul><li title="Shader attribute type: float">SHADER_ATTRIB_FLOAT</li>
<li title="Shader attribute type: vec2 (2 float)">SHADER_ATTRIB_VEC2 = 1</li>
<li title="Shader attribute type: vec3 (3 float)">SHADER_ATTRIB_VEC3 = 2</li>
<li title="Shader attribute type: vec4 (4 float)">SHADER_ATTRIB_VEC4 = 3</li></ul></td></tr>
<tr><td><b>PixelFormat</b></td><td>Pixel formats</td><td><ul><li title="8 bit per pixel (no alpha)">PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1</li>
<li title="8*2 bpp (2 channels)">PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2</li>
<li title="16 bpp">PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3</li>
<li title="24 bpp">PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4</li>
<li title="16 bpp (1 bit alpha)">PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5</li>
<li title="16 bpp (4 bit alpha)">PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6</li>
<li title="32 bpp">PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7</li>
<li title="32 bpp (1 channel - float)">PIXELFORMAT_UNCOMPRESSED_R32 = 8</li>
<li title="32*3 bpp (3 channels - float)">PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9</li>
<li title="32*4 bpp (4 channels - float)">PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10</li>
<li title="16 bpp (1 channel - half float)">PIXELFORMAT_UNCOMPRESSED_R16 = 11</li>
<li title="16*3 bpp (3 channels - half float)">PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12</li>
<li title="16*4 bpp (4 channels - half float)">PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13</li>
<li title="4 bpp (no alpha)">PIXELFORMAT_COMPRESSED_DXT1_RGB = 14</li>
<li title="4 bpp (1 bit alpha)">PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15</li>
<li title="8 bpp">PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16</li>
<li title="8 bpp">PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17</li>
<li title="4 bpp">PIXELFORMAT_COMPRESSED_ETC1_RGB = 18</li>
<li title="4 bpp">PIXELFORMAT_COMPRESSED_ETC2_RGB = 19</li>
<li title="8 bpp">PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20</li>
<li title="4 bpp">PIXELFORMAT_COMPRESSED_PVRT_RGB = 21</li>
<li title="4 bpp">PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22</li>
<li title="8 bpp">PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23</li>
<li title="2 bpp">PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24</li></ul></td></tr>
<tr><td><b>TextureFilter</b></td><td>Texture parameters: filter mode</td><td><ul><li title="No filter, just pixel approximation">TEXTURE_FILTER_POINT</li>
<li title="Linear filtering">TEXTURE_FILTER_BILINEAR = 1</li>
<li title="Trilinear filtering (linear with mipmaps)">TEXTURE_FILTER_TRILINEAR = 2</li>
<li title="Anisotropic filtering 4x">TEXTURE_FILTER_ANISOTROPIC_4X = 3</li>
<li title="Anisotropic filtering 8x">TEXTURE_FILTER_ANISOTROPIC_8X = 4</li>
<li title="Anisotropic filtering 16x">TEXTURE_FILTER_ANISOTROPIC_16X = 5</li></ul></td></tr>
<tr><td><b>TextureWrap</b></td><td>Texture parameters: wrap mode</td><td><ul><li title="Repeats texture in tiled mode">TEXTURE_WRAP_REPEAT</li>
<li title="Clamps texture to edge pixel in tiled mode">TEXTURE_WRAP_CLAMP = 1</li>
<li title="Mirrors and repeats the texture in tiled mode">TEXTURE_WRAP_MIRROR_REPEAT = 2</li>
<li title="Mirrors and clamps to border the texture in tiled mode">TEXTURE_WRAP_MIRROR_CLAMP = 3</li></ul></td></tr>
<tr><td><b>CubemapLayout</b></td><td>Cubemap layouts</td><td><ul><li title="Automatically detect layout type">CUBEMAP_LAYOUT_AUTO_DETECT</li>
<li title="Layout is defined by a vertical line with faces">CUBEMAP_LAYOUT_LINE_VERTICAL = 1</li>
<li title="Layout is defined by a horizontal line with faces">CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2</li>
<li title="Layout is defined by a 3x4 cross with cubemap faces">CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3</li>
<li title="Layout is defined by a 4x3 cross with cubemap faces">CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4</li>
<li title="Layout is defined by a panorama image (equirrectangular map)">CUBEMAP_LAYOUT_PANORAMA = 5</li></ul></td></tr>
<tr><td><b>FontType</b></td><td>Font type, defines generation method</td><td><ul><li title="Default font generation, anti-aliased">FONT_DEFAULT</li>
<li title="Bitmap font generation, no anti-aliasing">FONT_BITMAP = 1</li>
<li title="SDF font generation, requires external shader">FONT_SDF = 2</li></ul></td></tr>
<tr><td><b>BlendMode</b></td><td>Color blending modes (pre-defined)</td><td><ul><li title="Blend textures considering alpha (default)">BLEND_ALPHA</li>
<li title="Blend textures adding colors">BLEND_ADDITIVE = 1</li>
<li title="Blend textures multiplying colors">BLEND_MULTIPLIED = 2</li>
<li title="Blend textures adding colors (alternative)">BLEND_ADD_COLORS = 3</li>
<li title="Blend textures subtracting colors (alternative)">BLEND_SUBTRACT_COLORS = 4</li>
<li title="Blend premultiplied textures considering alpha">BLEND_ALPHA_PREMULTIPLY = 5</li>
<li title="Blend textures using custom src/dst factors (use rlSetBlendFactors())">BLEND_CUSTOM = 6</li>
<li title="Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate())">BLEND_CUSTOM_SEPARATE = 7</li></ul></td></tr>
<tr><td><b>Gesture</b></td><td>Gesture</td><td><ul><li title="No gesture">GESTURE_NONE</li>
<li title="Tap gesture">GESTURE_TAP = 1</li>
<li title="Double tap gesture">GESTURE_DOUBLETAP = 2</li>
<li title="Hold gesture">GESTURE_HOLD = 4</li>
<li title="Drag gesture">GESTURE_DRAG = 8</li>
<li title="Swipe right gesture">GESTURE_SWIPE_RIGHT = 16</li>
<li title="Swipe left gesture">GESTURE_SWIPE_LEFT = 32</li>
<li title="Swipe up gesture">GESTURE_SWIPE_UP = 64</li>
<li title="Swipe down gesture">GESTURE_SWIPE_DOWN = 128</li>
<li title="Pinch in gesture">GESTURE_PINCH_IN = 256</li>
<li title="Pinch out gesture">GESTURE_PINCH_OUT = 512</li></ul></td></tr>
<tr><td><b>CameraMode</b></td><td>Camera system modes</td><td><ul><li title="Custom camera">CAMERA_CUSTOM</li>
<li title="Free camera">CAMERA_FREE = 1</li>
<li title="Orbital camera">CAMERA_ORBITAL = 2</li>
<li title="First person camera">CAMERA_FIRST_PERSON = 3</li>
<li title="Third person camera">CAMERA_THIRD_PERSON = 4</li></ul></td></tr>
<tr><td><b>CameraProjection</b></td><td>Camera projection</td><td><ul><li title="Perspective projection">CAMERA_PERSPECTIVE</li>
<li title="Orthographic projection">CAMERA_ORTHOGRAPHIC = 1</li></ul></td></tr>
<tr><td><b>NPatchLayout</b></td><td>N-patch layout</td><td><ul><li title="Npatch layout: 3x3 tiles">NPATCH_NINE_PATCH</li>
<li title="Npatch layout: 1x3 tiles">NPATCH_THREE_PATCH_VERTICAL = 1</li>
<li title="Npatch layout: 3x1 tiles">NPATCH_THREE_PATCH_HORIZONTAL = 2</li></ul></td></tr>
</table>
  <br>

<h2 id=callbacks><a href="#top">callbacks</a></h2>
<table>
	<tr><th>name</th><th>description</th><th>returnType</th><th>params</th></tr>
	<tr><td><b>TraceLogCallback</b></td><td>Logging: Redirect trace log messages</td><td>void</td><td><ul><li>logLevel: int</li>
<li>text: const char *</li>
<li>args: va_list</li></ul></td></tr>
<tr><td><b>LoadFileDataCallback</b></td><td>FileIO: Load binary data</td><td>unsigned char *</td><td><ul><li>fileName: const char *</li>
<li>dataSize: int *</li></ul></td></tr>
<tr><td><b>SaveFileDataCallback</b></td><td>FileIO: Save binary data</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>data: void *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>LoadFileTextCallback</b></td><td>FileIO: Load text data</td><td>char *</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>SaveFileTextCallback</b></td><td>FileIO: Save text data</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>text: char *</li></ul></td></tr>
<tr><td><b>AudioCallback</b></td><td></td><td>void</td><td><ul><li>bufferData: void *</li>
<li>frames: unsigned int</li></ul></td></tr>
</table>
  <br>

<h2 id=functions><a href="#top">functions</a></h2>
<table>
	<tr><th>name</th><th>description</th><th>returnType</th><th>params</th></tr>
	<tr><td><b>InitWindow</b></td><td>Initialize window and OpenGL context</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>title: const char *</li></ul></td></tr>
<tr><td><b>CloseWindow</b></td><td>Close window and unload OpenGL context</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>WindowShouldClose</b></td><td>Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)</td><td>bool</td></tr>
<tr><td><b>IsWindowReady</b></td><td>Check if window has been initialized successfully</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowFullscreen</b></td><td>Check if window is currently fullscreen</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowHidden</b></td><td>Check if window is currently hidden (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowMinimized</b></td><td>Check if window is currently minimized (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowMaximized</b></td><td>Check if window is currently maximized (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowFocused</b></td><td>Check if window is currently focused (only PLATFORM_DESKTOP)</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowResized</b></td><td>Check if window has been resized last frame</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>IsWindowState</b></td><td>Check if one specific window flag is enabled</td><td>bool</td><td><ul><li>flag: unsigned int</li></ul></td></tr>
<tr><td><b>SetWindowState</b></td><td>Set window configuration state using flags (only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>ClearWindowState</b></td><td>Clear window configuration state flags</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>ToggleFullscreen</b></td><td>Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>ToggleBorderlessWindowed</b></td><td>Toggle window state: borderless windowed (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>MaximizeWindow</b></td><td>Set window state: maximized, if resizable (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>MinimizeWindow</b></td><td>Set window state: minimized, if resizable (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>RestoreWindow</b></td><td>Set window state: not minimized/maximized (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>SetWindowIcon</b></td><td>Set icon for window (single image, RGBA 32bit, only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>image: Image</li></ul></td></tr>
<tr><td><b>SetWindowIcons</b></td><td>Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>images: Image *</li>
<li>count: int</li></ul></td></tr>
<tr><td><b>SetWindowTitle</b></td><td>Set title for window (only PLATFORM_DESKTOP and PLATFORM_WEB)</td><td>void</td><td><ul><li>title: const char *</li></ul></td></tr>
<tr><td><b>SetWindowPosition</b></td><td>Set window position on screen (only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>x: int</li>
<li>y: int</li></ul></td></tr>
<tr><td><b>SetWindowMonitor</b></td><td>Set monitor for the current window</td><td>void</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>SetWindowMinSize</b></td><td>Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>SetWindowMaxSize</b></td><td>Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>SetWindowSize</b></td><td>Set window dimensions</td><td>void</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>SetWindowOpacity</b></td><td>Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)</td><td>void</td><td><ul><li>opacity: float</li></ul></td></tr>
<tr><td><b>SetWindowFocused</b></td><td>Set window focused (only PLATFORM_DESKTOP)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>GetWindowHandle</b></td><td>Get native window handle</td><td>void *</td><td><ul></ul></td></tr>
<tr><td><b>GetScreenWidth</b></td><td>Get current screen width</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetScreenHeight</b></td><td>Get current screen height</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetRenderWidth</b></td><td>Get current render width (it considers HiDPI)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetRenderHeight</b></td><td>Get current render height (it considers HiDPI)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetMonitorCount</b></td><td>Get number of connected monitors</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetCurrentMonitor</b></td><td>Get current connected monitor</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetMonitorPosition</b></td><td>Get specified monitor position</td><td>Vector2</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorWidth</b></td><td>Get specified monitor width (current video mode used by monitor)</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorHeight</b></td><td>Get specified monitor height (current video mode used by monitor)</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorPhysicalWidth</b></td><td>Get specified monitor physical width in millimetres</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorPhysicalHeight</b></td><td>Get specified monitor physical height in millimetres</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetMonitorRefreshRate</b></td><td>Get specified monitor refresh rate</td><td>int</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>GetWindowPosition</b></td><td>Get window position XY on monitor</td><td>Vector2</td></tr>
<tr><td><b>GetWindowScaleDPI</b></td><td>Get window scale DPI factor</td><td>Vector2</td></tr>
<tr><td><b>GetMonitorName</b></td><td>Get the human-readable, UTF-8 encoded name of the specified monitor</td><td>const char *</td><td><ul><li>monitor: int</li></ul></td></tr>
<tr><td><b>SetClipboardText</b></td><td>Set clipboard text content</td><td>void</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>GetClipboardText</b></td><td>Get clipboard text content</td><td>const char *</td><td><ul></ul></td></tr>
<tr><td><b>EnableEventWaiting</b></td><td>Enable waiting for events on EndDrawing(), no automatic event polling</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>DisableEventWaiting</b></td><td>Disable waiting for events on EndDrawing(), automatic events polling</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>ShowCursor</b></td><td>Shows cursor</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>HideCursor</b></td><td>Hides cursor</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsCursorHidden</b></td><td>Check if cursor is not visible</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>EnableCursor</b></td><td>Enables cursor (unlock cursor)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>DisableCursor</b></td><td>Disables cursor (lock cursor)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsCursorOnScreen</b></td><td>Check if cursor is on the screen</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>ClearBackground</b></td><td>Set background color (framebuffer clear color)</td><td>void</td><td><ul><li>color: Color</li></ul></td></tr>
<tr><td><b>BeginDrawing</b></td><td>Setup canvas (framebuffer) to start drawing</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>EndDrawing</b></td><td>End canvas drawing and swap buffers (double buffering)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginMode2D</b></td><td>Begin 2D mode with custom camera (2D)</td><td>void</td><td><ul><li>camera: Camera2D</li></ul></td></tr>
<tr><td><b>EndMode2D</b></td><td>Ends 2D mode with custom camera</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginMode3D</b></td><td>Begin 3D mode with custom camera (3D)</td><td>void</td><td><ul><li>camera: Camera3D</li></ul></td></tr>
<tr><td><b>EndMode3D</b></td><td>Ends 3D mode and returns to default 2D orthographic mode</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginTextureMode</b></td><td>Begin drawing to render texture</td><td>void</td><td><ul><li>target: RenderTexture2D</li></ul></td></tr>
<tr><td><b>EndTextureMode</b></td><td>Ends drawing to render texture</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginShaderMode</b></td><td>Begin custom shader drawing</td><td>void</td><td><ul><li>shader: Shader</li></ul></td></tr>
<tr><td><b>EndShaderMode</b></td><td>End custom shader drawing (use default shader)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginBlendMode</b></td><td>Begin blending mode (alpha, additive, multiplied, subtract, custom)</td><td>void</td><td><ul><li>mode: int</li></ul></td></tr>
<tr><td><b>EndBlendMode</b></td><td>End blending mode (reset to default: alpha blending)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginScissorMode</b></td><td>Begin scissor mode (define screen area for following drawing)</td><td>void</td><td><ul><li>x: int</li>
<li>y: int</li>
<li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>EndScissorMode</b></td><td>End scissor mode</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>BeginVrStereoMode</b></td><td>Begin stereo rendering (requires VR simulator)</td><td>void</td><td><ul><li>config: VrStereoConfig</li></ul></td></tr>
<tr><td><b>EndVrStereoMode</b></td><td>End stereo rendering (requires VR simulator)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>LoadVrStereoConfig</b></td><td>Load VR stereo config for VR simulator device parameters</td><td>VrStereoConfig</td><td><ul><li>device: VrDeviceInfo</li></ul></td></tr>
<tr><td><b>UnloadVrStereoConfig</b></td><td>Unload VR stereo config</td><td>void</td><td><ul><li>config: VrStereoConfig</li></ul></td></tr>
<tr><td><b>LoadShader</b></td><td>Load shader from files and bind default locations</td><td>Shader</td><td><ul><li>vsFileName: const char *</li>
<li>fsFileName: const char *</li></ul></td></tr>
<tr><td><b>LoadShaderFromMemory</b></td><td>Load shader from code strings and bind default locations</td><td>Shader</td><td><ul><li>vsCode: const char *</li>
<li>fsCode: const char *</li></ul></td></tr>
<tr><td><b>IsShaderReady</b></td><td>Check if a shader is ready</td><td>bool</td><td><ul><li>shader: Shader</li></ul></td></tr>
<tr><td><b>GetShaderLocation</b></td><td>Get shader uniform location</td><td>int</td><td><ul><li>shader: Shader</li>
<li>uniformName: const char *</li></ul></td></tr>
<tr><td><b>GetShaderLocationAttrib</b></td><td>Get shader attribute location</td><td>int</td><td><ul><li>shader: Shader</li>
<li>attribName: const char *</li></ul></td></tr>
<tr><td><b>SetShaderValue</b></td><td>Set shader uniform value</td><td>void</td><td><ul><li>shader: Shader</li>
<li>locIndex: int</li>
<li>value: const void *</li>
<li>uniformType: int</li></ul></td></tr>
<tr><td><b>SetShaderValueV</b></td><td>Set shader uniform value vector</td><td>void</td><td><ul><li>shader: Shader</li>
<li>locIndex: int</li>
<li>value: const void *</li>
<li>uniformType: int</li>
<li>count: int</li></ul></td></tr>
<tr><td><b>SetShaderValueMatrix</b></td><td>Set shader uniform value (matrix 4x4)</td><td>void</td><td><ul><li>shader: Shader</li>
<li>locIndex: int</li>
<li>mat: Matrix</li></ul></td></tr>
<tr><td><b>SetShaderValueTexture</b></td><td>Set shader uniform value for texture (sampler2d)</td><td>void</td><td><ul><li>shader: Shader</li>
<li>locIndex: int</li>
<li>texture: Texture2D</li></ul></td></tr>
<tr><td><b>UnloadShader</b></td><td>Unload shader from GPU memory (VRAM)</td><td>void</td><td><ul><li>shader: Shader</li></ul></td></tr>
<tr><td><b>GetMouseRay</b></td><td>Get a ray trace from mouse position</td><td>Ray</td><td><ul><li>mousePosition: Vector2</li>
<li>camera: Camera</li></ul></td></tr>
<tr><td><b>GetCameraMatrix</b></td><td>Get camera transform matrix (view matrix)</td><td>Matrix</td><td><ul><li>camera: Camera</li></ul></td></tr>
<tr><td><b>GetCameraMatrix2D</b></td><td>Get camera 2d transform matrix</td><td>Matrix</td><td><ul><li>camera: Camera2D</li></ul></td></tr>
<tr><td><b>GetWorldToScreen</b></td><td>Get the screen space position for a 3d world space position</td><td>Vector2</td><td><ul><li>position: Vector3</li>
<li>camera: Camera</li></ul></td></tr>
<tr><td><b>GetScreenToWorld2D</b></td><td>Get the world space position for a 2d camera screen space position</td><td>Vector2</td><td><ul><li>position: Vector2</li>
<li>camera: Camera2D</li></ul></td></tr>
<tr><td><b>GetWorldToScreenEx</b></td><td>Get size position for a 3d world space position</td><td>Vector2</td><td><ul><li>position: Vector3</li>
<li>camera: Camera</li>
<li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>GetWorldToScreen2D</b></td><td>Get the screen space position for a 2d camera world space position</td><td>Vector2</td><td><ul><li>position: Vector2</li>
<li>camera: Camera2D</li></ul></td></tr>
<tr><td><b>SetTargetFPS</b></td><td>Set target FPS (maximum)</td><td>void</td><td><ul><li>fps: int</li></ul></td></tr>
<tr><td><b>GetFrameTime</b></td><td>Get time in seconds for last frame drawn (delta time)</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetTime</b></td><td>Get elapsed time in seconds since InitWindow()</td><td>double</td><td><ul></ul></td></tr>
<tr><td><b>GetFPS</b></td><td>Get current FPS</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>SwapScreenBuffer</b></td><td>Swap back buffer with front buffer (screen drawing)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>PollInputEvents</b></td><td>Register all input events</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>WaitTime</b></td><td>Wait for some time (halt program execution)</td><td>void</td><td><ul><li>seconds: double</li></ul></td></tr>
<tr><td><b>SetRandomSeed</b></td><td>Set the seed for the random number generator</td><td>void</td><td><ul><li>seed: unsigned int</li></ul></td></tr>
<tr><td><b>GetRandomValue</b></td><td>Get a random value between min and max (both included)</td><td>int</td><td><ul><li>min: int</li>
<li>max: int</li></ul></td></tr>
<tr><td><b>LoadRandomSequence</b></td><td>Load random values sequence, no values repeated</td><td>int *</td><td><ul><li>count: unsigned int</li>
<li>min: int</li>
<li>max: int</li></ul></td></tr>
<tr><td><b>UnloadRandomSequence</b></td><td>Unload random values sequence</td><td>void</td><td><ul><li>sequence: int *</li></ul></td></tr>
<tr><td><b>TakeScreenshot</b></td><td>Takes a screenshot of current screen (filename extension defines format)</td><td>void</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>SetConfigFlags</b></td><td>Setup init configuration flags (view FLAGS)</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>OpenURL</b></td><td>Open URL with default system browser (if available)</td><td>void</td><td><ul><li>url: const char *</li></ul></td></tr>
<tr><td><b>TraceLog</b></td><td>Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)</td><td>void</td><td><ul><li>logLevel: int</li>
<li>text: const char *</li>
<li>args: ...</li></ul></td></tr>
<tr><td><b>SetTraceLogLevel</b></td><td>Set the current threshold (minimum) log level</td><td>void</td><td><ul><li>logLevel: int</li></ul></td></tr>
<tr><td><b>MemAlloc</b></td><td>Internal memory allocator</td><td>void *</td><td><ul><li>size: unsigned int</li></ul></td></tr>
<tr><td><b>MemRealloc</b></td><td>Internal memory reallocator</td><td>void *</td><td><ul><li>ptr: void *</li>
<li>size: unsigned int</li></ul></td></tr>
<tr><td><b>MemFree</b></td><td>Internal memory free</td><td>void</td><td><ul><li>ptr: void *</li></ul></td></tr>
<tr><td><b>SetTraceLogCallback</b></td><td>Set custom trace log</td><td>void</td><td><ul><li>callback: TraceLogCallback</li></ul></td></tr>
<tr><td><b>SetLoadFileDataCallback</b></td><td>Set custom file binary data loader</td><td>void</td><td><ul><li>callback: LoadFileDataCallback</li></ul></td></tr>
<tr><td><b>SetSaveFileDataCallback</b></td><td>Set custom file binary data saver</td><td>void</td><td><ul><li>callback: SaveFileDataCallback</li></ul></td></tr>
<tr><td><b>SetLoadFileTextCallback</b></td><td>Set custom file text data loader</td><td>void</td><td><ul><li>callback: LoadFileTextCallback</li></ul></td></tr>
<tr><td><b>SetSaveFileTextCallback</b></td><td>Set custom file text data saver</td><td>void</td><td><ul><li>callback: SaveFileTextCallback</li></ul></td></tr>
<tr><td><b>LoadFileData</b></td><td>Load file data as byte array (read)</td><td>unsigned char *</td><td><ul><li>fileName: const char *</li>
<li>dataSize: int *</li></ul></td></tr>
<tr><td><b>UnloadFileData</b></td><td>Unload file data allocated by LoadFileData()</td><td>void</td><td><ul><li>data: unsigned char *</li></ul></td></tr>
<tr><td><b>SaveFileData</b></td><td>Save data to file from byte array (write), returns true on success</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>data: void *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>ExportDataAsCode</b></td><td>Export data to code (.h), returns true on success</td><td>bool</td><td><ul><li>data: const unsigned char *</li>
<li>dataSize: int</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadFileText</b></td><td>Load text data from file (read), returns a '\0' terminated string</td><td>char *</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>UnloadFileText</b></td><td>Unload file text data allocated by LoadFileText()</td><td>void</td><td><ul><li>text: char *</li></ul></td></tr>
<tr><td><b>SaveFileText</b></td><td>Save text data to file (write), string must be '\0' terminated, returns true on success</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>text: char *</li></ul></td></tr>
<tr><td><b>FileExists</b></td><td>Check if file exists</td><td>bool</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>DirectoryExists</b></td><td>Check if a directory path exists</td><td>bool</td><td><ul><li>dirPath: const char *</li></ul></td></tr>
<tr><td><b>IsFileExtension</b></td><td>Check file extension (including point: .png, .wav)</td><td>bool</td><td><ul><li>fileName: const char *</li>
<li>ext: const char *</li></ul></td></tr>
<tr><td><b>GetFileLength</b></td><td>Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)</td><td>int</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>GetFileExtension</b></td><td>Get pointer to extension for a filename string (includes dot: '.png')</td><td>const char *</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>GetFileName</b></td><td>Get pointer to filename for a path string</td><td>const char *</td><td><ul><li>filePath: const char *</li></ul></td></tr>
<tr><td><b>GetFileNameWithoutExt</b></td><td>Get filename string without extension (uses static string)</td><td>const char *</td><td><ul><li>filePath: const char *</li></ul></td></tr>
<tr><td><b>GetDirectoryPath</b></td><td>Get full path for a given fileName with path (uses static string)</td><td>const char *</td><td><ul><li>filePath: const char *</li></ul></td></tr>
<tr><td><b>GetPrevDirectoryPath</b></td><td>Get previous directory path for a given path (uses static string)</td><td>const char *</td><td><ul><li>dirPath: const char *</li></ul></td></tr>
<tr><td><b>GetWorkingDirectory</b></td><td>Get current working directory (uses static string)</td><td>const char *</td><td><ul></ul></td></tr>
<tr><td><b>GetApplicationDirectory</b></td><td>Get the directory of the running application (uses static string)</td><td>const char *</td><td><ul></ul></td></tr>
<tr><td><b>ChangeDirectory</b></td><td>Change working directory, return true on success</td><td>bool</td><td><ul><li>dir: const char *</li></ul></td></tr>
<tr><td><b>IsPathFile</b></td><td>Check if a given path is a file or a directory</td><td>bool</td><td><ul><li>path: const char *</li></ul></td></tr>
<tr><td><b>LoadDirectoryFiles</b></td><td>Load directory filepaths</td><td>FilePathList</td><td><ul><li>dirPath: const char *</li></ul></td></tr>
<tr><td><b>LoadDirectoryFilesEx</b></td><td>Load directory filepaths with extension filtering and recursive directory scan</td><td>FilePathList</td><td><ul><li>basePath: const char *</li>
<li>filter: const char *</li>
<li>scanSubdirs: bool</li></ul></td></tr>
<tr><td><b>UnloadDirectoryFiles</b></td><td>Unload filepaths</td><td>void</td><td><ul><li>files: FilePathList</li></ul></td></tr>
<tr><td><b>IsFileDropped</b></td><td>Check if a file has been dropped into window</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>LoadDroppedFiles</b></td><td>Load dropped filepaths</td><td>FilePathList</td></tr>
<tr><td><b>UnloadDroppedFiles</b></td><td>Unload dropped filepaths</td><td>void</td><td><ul><li>files: FilePathList</li></ul></td></tr>
<tr><td><b>GetFileModTime</b></td><td>Get file modification time (last write time)</td><td>long</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>CompressData</b></td><td>Compress data (DEFLATE algorithm), memory must be MemFree()</td><td>unsigned char *</td><td><ul><li>data: const unsigned char *</li>
<li>dataSize: int</li>
<li>compDataSize: int *</li></ul></td></tr>
<tr><td><b>DecompressData</b></td><td>Decompress data (DEFLATE algorithm), memory must be MemFree()</td><td>unsigned char *</td><td><ul><li>compData: const unsigned char *</li>
<li>compDataSize: int</li>
<li>dataSize: int *</li></ul></td></tr>
<tr><td><b>EncodeDataBase64</b></td><td>Encode data to Base64 string, memory must be MemFree()</td><td>char *</td><td><ul><li>data: const unsigned char *</li>
<li>dataSize: int</li>
<li>outputSize: int *</li></ul></td></tr>
<tr><td><b>DecodeDataBase64</b></td><td>Decode Base64 string data, memory must be MemFree()</td><td>unsigned char *</td><td><ul><li>data: const unsigned char *</li>
<li>outputSize: int *</li></ul></td></tr>
<tr><td><b>LoadAutomationEventList</b></td><td>Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS</td><td>AutomationEventList</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>UnloadAutomationEventList</b></td><td>Unload automation events list from file</td><td>void</td><td><ul><li>list: AutomationEventList *</li></ul></td></tr>
<tr><td><b>ExportAutomationEventList</b></td><td>Export automation events list as text file</td><td>bool</td><td><ul><li>list: AutomationEventList</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>SetAutomationEventList</b></td><td>Set automation event list to record to</td><td>void</td><td><ul><li>list: AutomationEventList *</li></ul></td></tr>
<tr><td><b>SetAutomationEventBaseFrame</b></td><td>Set automation event internal base frame to start recording</td><td>void</td><td><ul><li>frame: int</li></ul></td></tr>
<tr><td><b>StartAutomationEventRecording</b></td><td>Start recording automation events (AutomationEventList must be set)</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>StopAutomationEventRecording</b></td><td>Stop recording automation events</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>PlayAutomationEvent</b></td><td>Play a recorded automation event</td><td>void</td><td><ul><li>event: AutomationEvent</li></ul></td></tr>
<tr><td><b>IsKeyPressed</b></td><td>Check if a key has been pressed once</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyPressedRepeat</b></td><td>Check if a key has been pressed again (Only PLATFORM_DESKTOP)</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyDown</b></td><td>Check if a key is being pressed</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyReleased</b></td><td>Check if a key has been released once</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsKeyUp</b></td><td>Check if a key is NOT being pressed</td><td>bool</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>GetKeyPressed</b></td><td>Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetCharPressed</b></td><td>Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>SetExitKey</b></td><td>Set a custom key to exit program (default is ESC)</td><td>void</td><td><ul><li>key: int</li></ul></td></tr>
<tr><td><b>IsGamepadAvailable</b></td><td>Check if a gamepad is available</td><td>bool</td><td><ul><li>gamepad: int</li></ul></td></tr>
<tr><td><b>GetGamepadName</b></td><td>Get gamepad internal name id</td><td>const char *</td><td><ul><li>gamepad: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonPressed</b></td><td>Check if a gamepad button has been pressed once</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonDown</b></td><td>Check if a gamepad button is being pressed</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonReleased</b></td><td>Check if a gamepad button has been released once</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>IsGamepadButtonUp</b></td><td>Check if a gamepad button is NOT being pressed</td><td>bool</td><td><ul><li>gamepad: int</li>
<li>button: int</li></ul></td></tr>
<tr><td><b>GetGamepadButtonPressed</b></td><td>Get the last gamepad button pressed</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetGamepadAxisCount</b></td><td>Get gamepad axis count for a gamepad</td><td>int</td><td><ul><li>gamepad: int</li></ul></td></tr>
<tr><td><b>GetGamepadAxisMovement</b></td><td>Get axis movement value for a gamepad axis</td><td>float</td><td><ul><li>gamepad: int</li>
<li>axis: int</li></ul></td></tr>
<tr><td><b>SetGamepadMappings</b></td><td>Set internal gamepad mappings (SDL_GameControllerDB)</td><td>int</td><td><ul><li>mappings: const char *</li></ul></td></tr>
<tr><td><b>IsMouseButtonPressed</b></td><td>Check if a mouse button has been pressed once</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>IsMouseButtonDown</b></td><td>Check if a mouse button is being pressed</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>IsMouseButtonReleased</b></td><td>Check if a mouse button has been released once</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>IsMouseButtonUp</b></td><td>Check if a mouse button is NOT being pressed</td><td>bool</td><td><ul><li>button: int</li></ul></td></tr>
<tr><td><b>GetMouseX</b></td><td>Get mouse position X</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetMouseY</b></td><td>Get mouse position Y</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetMousePosition</b></td><td>Get mouse position XY</td><td>Vector2</td></tr>
<tr><td><b>GetMouseDelta</b></td><td>Get mouse delta between frames</td><td>Vector2</td></tr>
<tr><td><b>SetMousePosition</b></td><td>Set mouse position XY</td><td>void</td><td><ul><li>x: int</li>
<li>y: int</li></ul></td></tr>
<tr><td><b>SetMouseOffset</b></td><td>Set mouse offset</td><td>void</td><td><ul><li>offsetX: int</li>
<li>offsetY: int</li></ul></td></tr>
<tr><td><b>SetMouseScale</b></td><td>Set mouse scaling</td><td>void</td><td><ul><li>scaleX: float</li>
<li>scaleY: float</li></ul></td></tr>
<tr><td><b>GetMouseWheelMove</b></td><td>Get mouse wheel movement for X or Y, whichever is larger</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetMouseWheelMoveV</b></td><td>Get mouse wheel movement for both X and Y</td><td>Vector2</td></tr>
<tr><td><b>SetMouseCursor</b></td><td>Set mouse cursor</td><td>void</td><td><ul><li>cursor: int</li></ul></td></tr>
<tr><td><b>GetTouchX</b></td><td>Get touch position X for touch point 0 (relative to screen size)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetTouchY</b></td><td>Get touch position Y for touch point 0 (relative to screen size)</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetTouchPosition</b></td><td>Get touch position XY for a touch point index (relative to screen size)</td><td>Vector2</td><td><ul><li>index: int</li></ul></td></tr>
<tr><td><b>GetTouchPointId</b></td><td>Get touch point identifier for given index</td><td>int</td><td><ul><li>index: int</li></ul></td></tr>
<tr><td><b>GetTouchPointCount</b></td><td>Get number of touch points</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>SetGesturesEnabled</b></td><td>Enable a set of gestures using flags</td><td>void</td><td><ul><li>flags: unsigned int</li></ul></td></tr>
<tr><td><b>IsGestureDetected</b></td><td>Check if a gesture have been detected</td><td>bool</td><td><ul><li>gesture: unsigned int</li></ul></td></tr>
<tr><td><b>GetGestureDetected</b></td><td>Get latest detected gesture</td><td>int</td><td><ul></ul></td></tr>
<tr><td><b>GetGestureHoldDuration</b></td><td>Get gesture hold time in milliseconds</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetGestureDragVector</b></td><td>Get gesture drag vector</td><td>Vector2</td></tr>
<tr><td><b>GetGestureDragAngle</b></td><td>Get gesture drag angle</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>GetGesturePinchVector</b></td><td>Get gesture pinch delta</td><td>Vector2</td></tr>
<tr><td><b>GetGesturePinchAngle</b></td><td>Get gesture pinch angle</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>UpdateCamera</b></td><td>Update camera position for selected mode</td><td>void</td><td><ul><li>camera: Camera *</li>
<li>mode: int</li></ul></td></tr>
<tr><td><b>UpdateCameraPro</b></td><td>Update camera movement/rotation</td><td>void</td><td><ul><li>camera: Camera *</li>
<li>movement: Vector3</li>
<li>rotation: Vector3</li>
<li>zoom: float</li></ul></td></tr>
<tr><td><b>SetShapesTexture</b></td><td>Set texture and rectangle to be used on shapes drawing</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>source: Rectangle</li></ul></td></tr>
<tr><td><b>DrawPixel</b></td><td>Draw a pixel</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawPixelV</b></td><td>Draw a pixel (Vector version)</td><td>void</td><td><ul><li>position: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawLine</b></td><td>Draw a line</td><td>void</td><td><ul><li>startPosX: int</li>
<li>startPosY: int</li>
<li>endPosX: int</li>
<li>endPosY: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawLineV</b></td><td>Draw a line (using gl lines)</td><td>void</td><td><ul><li>startPos: Vector2</li>
<li>endPos: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawLineEx</b></td><td>Draw a line (using triangles/quads)</td><td>void</td><td><ul><li>startPos: Vector2</li>
<li>endPos: Vector2</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawLineStrip</b></td><td>Draw lines sequence (using gl lines)</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawLineBezier</b></td><td>Draw line segment cubic-bezier in-out interpolation</td><td>void</td><td><ul><li>startPos: Vector2</li>
<li>endPos: Vector2</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCircle</b></td><td>Draw a color-filled circle</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radius: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCircleSector</b></td><td>Draw a piece of a circle</td><td>void</td><td><ul><li>center: Vector2</li>
<li>radius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCircleSectorLines</b></td><td>Draw circle sector outline</td><td>void</td><td><ul><li>center: Vector2</li>
<li>radius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCircleGradient</b></td><td>Draw a gradient-filled circle</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radius: float</li>
<li>color1: Color</li>
<li>color2: Color</li></ul></td></tr>
<tr><td><b>DrawCircleV</b></td><td>Draw a color-filled circle (Vector version)</td><td>void</td><td><ul><li>center: Vector2</li>
<li>radius: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCircleLines</b></td><td>Draw circle outline</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radius: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCircleLinesV</b></td><td>Draw circle outline (Vector version)</td><td>void</td><td><ul><li>center: Vector2</li>
<li>radius: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawEllipse</b></td><td>Draw ellipse</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radiusH: float</li>
<li>radiusV: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawEllipseLines</b></td><td>Draw ellipse outline</td><td>void</td><td><ul><li>centerX: int</li>
<li>centerY: int</li>
<li>radiusH: float</li>
<li>radiusV: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRing</b></td><td>Draw ring</td><td>void</td><td><ul><li>center: Vector2</li>
<li>innerRadius: float</li>
<li>outerRadius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRingLines</b></td><td>Draw ring outline</td><td>void</td><td><ul><li>center: Vector2</li>
<li>innerRadius: float</li>
<li>outerRadius: float</li>
<li>startAngle: float</li>
<li>endAngle: float</li>
<li>segments: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectangle</b></td><td>Draw a color-filled rectangle</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleV</b></td><td>Draw a color-filled rectangle (Vector version)</td><td>void</td><td><ul><li>position: Vector2</li>
<li>size: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleRec</b></td><td>Draw a color-filled rectangle</td><td>void</td><td><ul><li>rec: Rectangle</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectanglePro</b></td><td>Draw a color-filled rectangle with pro parameters</td><td>void</td><td><ul><li>rec: Rectangle</li>
<li>origin: Vector2</li>
<li>rotation: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleGradientV</b></td><td>Draw a vertical-gradient-filled rectangle</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color1: Color</li>
<li>color2: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleGradientH</b></td><td>Draw a horizontal-gradient-filled rectangle</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color1: Color</li>
<li>color2: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleGradientEx</b></td><td>Draw a gradient-filled rectangle with custom vertex colors</td><td>void</td><td><ul><li>rec: Rectangle</li>
<li>col1: Color</li>
<li>col2: Color</li>
<li>col3: Color</li>
<li>col4: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleLines</b></td><td>Draw rectangle outline</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleLinesEx</b></td><td>Draw rectangle outline with extended parameters</td><td>void</td><td><ul><li>rec: Rectangle</li>
<li>lineThick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleRounded</b></td><td>Draw rectangle with rounded edges</td><td>void</td><td><ul><li>rec: Rectangle</li>
<li>roundness: float</li>
<li>segments: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRectangleRoundedLines</b></td><td>Draw rectangle with rounded edges outline</td><td>void</td><td><ul><li>rec: Rectangle</li>
<li>roundness: float</li>
<li>segments: int</li>
<li>lineThick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawTriangle</b></td><td>Draw a color-filled triangle (vertex in counter-clockwise order!)</td><td>void</td><td><ul><li>v1: Vector2</li>
<li>v2: Vector2</li>
<li>v3: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawTriangleLines</b></td><td>Draw triangle outline (vertex in counter-clockwise order!)</td><td>void</td><td><ul><li>v1: Vector2</li>
<li>v2: Vector2</li>
<li>v3: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawTriangleFan</b></td><td>Draw a triangle fan defined by points (first vertex is the center)</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawTriangleStrip</b></td><td>Draw a triangle strip defined by points</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawPoly</b></td><td>Draw a regular polygon (Vector version)</td><td>void</td><td><ul><li>center: Vector2</li>
<li>sides: int</li>
<li>radius: float</li>
<li>rotation: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawPolyLines</b></td><td>Draw a polygon outline of n sides</td><td>void</td><td><ul><li>center: Vector2</li>
<li>sides: int</li>
<li>radius: float</li>
<li>rotation: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawPolyLinesEx</b></td><td>Draw a polygon outline of n sides with extended parameters</td><td>void</td><td><ul><li>center: Vector2</li>
<li>sides: int</li>
<li>radius: float</li>
<li>rotation: float</li>
<li>lineThick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineLinear</b></td><td>Draw spline: Linear, minimum 2 points</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineBasis</b></td><td>Draw spline: B-Spline, minimum 4 points</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineCatmullRom</b></td><td>Draw spline: Catmull-Rom, minimum 4 points</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineBezierQuadratic</b></td><td>Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineBezierCubic</b></td><td>Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]</td><td>void</td><td><ul><li>points: Vector2 *</li>
<li>pointCount: int</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineSegmentLinear</b></td><td>Draw spline segment: Linear, 2 points</td><td>void</td><td><ul><li>p1: Vector2</li>
<li>p2: Vector2</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineSegmentBasis</b></td><td>Draw spline segment: B-Spline, 4 points</td><td>void</td><td><ul><li>p1: Vector2</li>
<li>p2: Vector2</li>
<li>p3: Vector2</li>
<li>p4: Vector2</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineSegmentCatmullRom</b></td><td>Draw spline segment: Catmull-Rom, 4 points</td><td>void</td><td><ul><li>p1: Vector2</li>
<li>p2: Vector2</li>
<li>p3: Vector2</li>
<li>p4: Vector2</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineSegmentBezierQuadratic</b></td><td>Draw spline segment: Quadratic Bezier, 2 points, 1 control point</td><td>void</td><td><ul><li>p1: Vector2</li>
<li>c2: Vector2</li>
<li>p3: Vector2</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSplineSegmentBezierCubic</b></td><td>Draw spline segment: Cubic Bezier, 2 points, 2 control points</td><td>void</td><td><ul><li>p1: Vector2</li>
<li>c2: Vector2</li>
<li>c3: Vector2</li>
<li>p4: Vector2</li>
<li>thick: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>GetSplinePointLinear</b></td><td>Get (evaluate) spline point: Linear</td><td>Vector2</td><td><ul><li>startPos: Vector2</li>
<li>endPos: Vector2</li>
<li>t: float</li></ul></td></tr>
<tr><td><b>GetSplinePointBasis</b></td><td>Get (evaluate) spline point: B-Spline</td><td>Vector2</td><td><ul><li>p1: Vector2</li>
<li>p2: Vector2</li>
<li>p3: Vector2</li>
<li>p4: Vector2</li>
<li>t: float</li></ul></td></tr>
<tr><td><b>GetSplinePointCatmullRom</b></td><td>Get (evaluate) spline point: Catmull-Rom</td><td>Vector2</td><td><ul><li>p1: Vector2</li>
<li>p2: Vector2</li>
<li>p3: Vector2</li>
<li>p4: Vector2</li>
<li>t: float</li></ul></td></tr>
<tr><td><b>GetSplinePointBezierQuad</b></td><td>Get (evaluate) spline point: Quadratic Bezier</td><td>Vector2</td><td><ul><li>p1: Vector2</li>
<li>c2: Vector2</li>
<li>p3: Vector2</li>
<li>t: float</li></ul></td></tr>
<tr><td><b>GetSplinePointBezierCubic</b></td><td>Get (evaluate) spline point: Cubic Bezier</td><td>Vector2</td><td><ul><li>p1: Vector2</li>
<li>c2: Vector2</li>
<li>c3: Vector2</li>
<li>p4: Vector2</li>
<li>t: float</li></ul></td></tr>
<tr><td><b>CheckCollisionRecs</b></td><td>Check collision between two rectangles</td><td>bool</td><td><ul><li>rec1: Rectangle</li>
<li>rec2: Rectangle</li></ul></td></tr>
<tr><td><b>CheckCollisionCircles</b></td><td>Check collision between two circles</td><td>bool</td><td><ul><li>center1: Vector2</li>
<li>radius1: float</li>
<li>center2: Vector2</li>
<li>radius2: float</li></ul></td></tr>
<tr><td><b>CheckCollisionCircleRec</b></td><td>Check collision between circle and rectangle</td><td>bool</td><td><ul><li>center: Vector2</li>
<li>radius: float</li>
<li>rec: Rectangle</li></ul></td></tr>
<tr><td><b>CheckCollisionPointRec</b></td><td>Check if point is inside rectangle</td><td>bool</td><td><ul><li>point: Vector2</li>
<li>rec: Rectangle</li></ul></td></tr>
<tr><td><b>CheckCollisionPointCircle</b></td><td>Check if point is inside circle</td><td>bool</td><td><ul><li>point: Vector2</li>
<li>center: Vector2</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>CheckCollisionPointTriangle</b></td><td>Check if point is inside a triangle</td><td>bool</td><td><ul><li>point: Vector2</li>
<li>p1: Vector2</li>
<li>p2: Vector2</li>
<li>p3: Vector2</li></ul></td></tr>
<tr><td><b>CheckCollisionPointPoly</b></td><td>Check if point is within a polygon described by array of vertices</td><td>bool</td><td><ul><li>point: Vector2</li>
<li>points: Vector2 *</li>
<li>pointCount: int</li></ul></td></tr>
<tr><td><b>CheckCollisionLines</b></td><td>Check the collision between two lines defined by two points each, returns collision point by reference</td><td>bool</td><td><ul><li>startPos1: Vector2</li>
<li>endPos1: Vector2</li>
<li>startPos2: Vector2</li>
<li>endPos2: Vector2</li>
<li>collisionPoint: Vector2 *</li></ul></td></tr>
<tr><td><b>CheckCollisionPointLine</b></td><td>Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]</td><td>bool</td><td><ul><li>point: Vector2</li>
<li>p1: Vector2</li>
<li>p2: Vector2</li>
<li>threshold: int</li></ul></td></tr>
<tr><td><b>GetCollisionRec</b></td><td>Get collision rectangle for two rectangles collision</td><td>Rectangle</td><td><ul><li>rec1: Rectangle</li>
<li>rec2: Rectangle</li></ul></td></tr>
<tr><td><b>LoadImage</b></td><td>Load image from file into CPU memory (RAM)</td><td>Image</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadImageRaw</b></td><td>Load image from RAW file data</td><td>Image</td><td><ul><li>fileName: const char *</li>
<li>width: int</li>
<li>height: int</li>
<li>format: int</li>
<li>headerSize: int</li></ul></td></tr>
<tr><td><b>LoadImageSvg</b></td><td>Load image from SVG file data or string with specified size</td><td>Image</td><td><ul><li>fileNameOrString: const char *</li>
<li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>LoadImageAnim</b></td><td>Load image sequence from file (frames appended to image.data)</td><td>Image</td><td><ul><li>fileName: const char *</li>
<li>frames: int *</li></ul></td></tr>
<tr><td><b>LoadImageFromMemory</b></td><td>Load image from memory buffer, fileType refers to extension: i.e. '.png'</td><td>Image</td><td><ul><li>fileType: const char *</li>
<li>fileData: const unsigned char *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>LoadImageFromTexture</b></td><td>Load image from GPU texture data</td><td>Image</td><td><ul><li>texture: Texture2D</li></ul></td></tr>
<tr><td><b>LoadImageFromScreen</b></td><td>Load image from screen buffer and (screenshot)</td><td>Image</td></tr>
<tr><td><b>IsImageReady</b></td><td>Check if an image is ready</td><td>bool</td><td><ul><li>image: Image</li></ul></td></tr>
<tr><td><b>UnloadImage</b></td><td>Unload image from CPU memory (RAM)</td><td>void</td><td><ul><li>image: Image</li></ul></td></tr>
<tr><td><b>ExportImage</b></td><td>Export image data to file, returns true on success</td><td>bool</td><td><ul><li>image: Image</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>ExportImageToMemory</b></td><td>Export image to memory buffer</td><td>unsigned char *</td><td><ul><li>image: Image</li>
<li>fileType: const char *</li>
<li>fileSize: int *</li></ul></td></tr>
<tr><td><b>ExportImageAsCode</b></td><td>Export image as code file defining an array of bytes, returns true on success</td><td>bool</td><td><ul><li>image: Image</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>GenImageColor</b></td><td>Generate image: plain color</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>GenImageGradientLinear</b></td><td>Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>direction: int</li>
<li>start: Color</li>
<li>end: Color</li></ul></td></tr>
<tr><td><b>GenImageGradientRadial</b></td><td>Generate image: radial gradient</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>density: float</li>
<li>inner: Color</li>
<li>outer: Color</li></ul></td></tr>
<tr><td><b>GenImageGradientSquare</b></td><td>Generate image: square gradient</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>density: float</li>
<li>inner: Color</li>
<li>outer: Color</li></ul></td></tr>
<tr><td><b>GenImageChecked</b></td><td>Generate image: checked</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>checksX: int</li>
<li>checksY: int</li>
<li>col1: Color</li>
<li>col2: Color</li></ul></td></tr>
<tr><td><b>GenImageWhiteNoise</b></td><td>Generate image: white noise</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>factor: float</li></ul></td></tr>
<tr><td><b>GenImagePerlinNoise</b></td><td>Generate image: perlin noise</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>offsetX: int</li>
<li>offsetY: int</li>
<li>scale: float</li></ul></td></tr>
<tr><td><b>GenImageCellular</b></td><td>Generate image: cellular algorithm, bigger tileSize means bigger cells</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>tileSize: int</li></ul></td></tr>
<tr><td><b>GenImageText</b></td><td>Generate image: grayscale image from text data</td><td>Image</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>text: const char *</li></ul></td></tr>
<tr><td><b>ImageCopy</b></td><td>Create an image duplicate (useful for transformations)</td><td>Image</td><td><ul><li>image: Image</li></ul></td></tr>
<tr><td><b>ImageFromImage</b></td><td>Create an image from another image piece</td><td>Image</td><td><ul><li>image: Image</li>
<li>rec: Rectangle</li></ul></td></tr>
<tr><td><b>ImageText</b></td><td>Create an image from text (default font)</td><td>Image</td><td><ul><li>text: const char *</li>
<li>fontSize: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageTextEx</b></td><td>Create an image from text (custom sprite font)</td><td>Image</td><td><ul><li>font: Font</li>
<li>text: const char *</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>ImageFormat</b></td><td>Convert image data to desired format</td><td>void</td><td><ul><li>image: Image *</li>
<li>newFormat: int</li></ul></td></tr>
<tr><td><b>ImageToPOT</b></td><td>Convert image to POT (power-of-two)</td><td>void</td><td><ul><li>image: Image *</li>
<li>fill: Color</li></ul></td></tr>
<tr><td><b>ImageCrop</b></td><td>Crop an image to a defined rectangle</td><td>void</td><td><ul><li>image: Image *</li>
<li>crop: Rectangle</li></ul></td></tr>
<tr><td><b>ImageAlphaCrop</b></td><td>Crop image depending on alpha value</td><td>void</td><td><ul><li>image: Image *</li>
<li>threshold: float</li></ul></td></tr>
<tr><td><b>ImageAlphaClear</b></td><td>Clear alpha channel to desired color</td><td>void</td><td><ul><li>image: Image *</li>
<li>color: Color</li>
<li>threshold: float</li></ul></td></tr>
<tr><td><b>ImageAlphaMask</b></td><td>Apply alpha mask to image</td><td>void</td><td><ul><li>image: Image *</li>
<li>alphaMask: Image</li></ul></td></tr>
<tr><td><b>ImageAlphaPremultiply</b></td><td>Premultiply alpha channel</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageBlurGaussian</b></td><td>Apply Gaussian blur using a box blur approximation</td><td>void</td><td><ul><li>image: Image *</li>
<li>blurSize: int</li></ul></td></tr>
<tr><td><b>ImageResize</b></td><td>Resize image (Bicubic scaling algorithm)</td><td>void</td><td><ul><li>image: Image *</li>
<li>newWidth: int</li>
<li>newHeight: int</li></ul></td></tr>
<tr><td><b>ImageResizeNN</b></td><td>Resize image (Nearest-Neighbor scaling algorithm)</td><td>void</td><td><ul><li>image: Image *</li>
<li>newWidth: int</li>
<li>newHeight: int</li></ul></td></tr>
<tr><td><b>ImageResizeCanvas</b></td><td>Resize canvas and fill with color</td><td>void</td><td><ul><li>image: Image *</li>
<li>newWidth: int</li>
<li>newHeight: int</li>
<li>offsetX: int</li>
<li>offsetY: int</li>
<li>fill: Color</li></ul></td></tr>
<tr><td><b>ImageMipmaps</b></td><td>Compute all mipmap levels for a provided image</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageDither</b></td><td>Dither image data to 16bpp or lower (Floyd-Steinberg dithering)</td><td>void</td><td><ul><li>image: Image *</li>
<li>rBpp: int</li>
<li>gBpp: int</li>
<li>bBpp: int</li>
<li>aBpp: int</li></ul></td></tr>
<tr><td><b>ImageFlipVertical</b></td><td>Flip image vertically</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageFlipHorizontal</b></td><td>Flip image horizontally</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageRotate</b></td><td>Rotate image by input angle in degrees (-359 to 359)</td><td>void</td><td><ul><li>image: Image *</li>
<li>degrees: int</li></ul></td></tr>
<tr><td><b>ImageRotateCW</b></td><td>Rotate image clockwise 90deg</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageRotateCCW</b></td><td>Rotate image counter-clockwise 90deg</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageColorTint</b></td><td>Modify image color: tint</td><td>void</td><td><ul><li>image: Image *</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageColorInvert</b></td><td>Modify image color: invert</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageColorGrayscale</b></td><td>Modify image color: grayscale</td><td>void</td><td><ul><li>image: Image *</li></ul></td></tr>
<tr><td><b>ImageColorContrast</b></td><td>Modify image color: contrast (-100 to 100)</td><td>void</td><td><ul><li>image: Image *</li>
<li>contrast: float</li></ul></td></tr>
<tr><td><b>ImageColorBrightness</b></td><td>Modify image color: brightness (-255 to 255)</td><td>void</td><td><ul><li>image: Image *</li>
<li>brightness: int</li></ul></td></tr>
<tr><td><b>ImageColorReplace</b></td><td>Modify image color: replace color</td><td>void</td><td><ul><li>image: Image *</li>
<li>color: Color</li>
<li>replace: Color</li></ul></td></tr>
<tr><td><b>LoadImageColors</b></td><td>Load color data from image as a Color array (RGBA - 32bit)</td><td>Color *</td><td><ul><li>image: Image</li></ul></td></tr>
<tr><td><b>LoadImagePalette</b></td><td>Load colors palette from image as a Color array (RGBA - 32bit)</td><td>Color *</td><td><ul><li>image: Image</li>
<li>maxPaletteSize: int</li>
<li>colorCount: int *</li></ul></td></tr>
<tr><td><b>UnloadImageColors</b></td><td>Unload color data loaded with LoadImageColors()</td><td>void</td><td><ul><li>colors: Color *</li></ul></td></tr>
<tr><td><b>UnloadImagePalette</b></td><td>Unload colors palette loaded with LoadImagePalette()</td><td>void</td><td><ul><li>colors: Color *</li></ul></td></tr>
<tr><td><b>GetImageAlphaBorder</b></td><td>Get image alpha border rectangle</td><td>Rectangle</td><td><ul><li>image: Image</li>
<li>threshold: float</li></ul></td></tr>
<tr><td><b>GetImageColor</b></td><td>Get image pixel color at (x, y) position</td><td>Color</td><td><ul><li>image: Image</li>
<li>x: int</li>
<li>y: int</li></ul></td></tr>
<tr><td><b>ImageClearBackground</b></td><td>Clear image background with given color</td><td>void</td><td><ul><li>dst: Image *</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawPixel</b></td><td>Draw pixel within an image</td><td>void</td><td><ul><li>dst: Image *</li>
<li>posX: int</li>
<li>posY: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawPixelV</b></td><td>Draw pixel within an image (Vector version)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>position: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawLine</b></td><td>Draw line within an image</td><td>void</td><td><ul><li>dst: Image *</li>
<li>startPosX: int</li>
<li>startPosY: int</li>
<li>endPosX: int</li>
<li>endPosY: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawLineV</b></td><td>Draw line within an image (Vector version)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>start: Vector2</li>
<li>end: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawCircle</b></td><td>Draw a filled circle within an image</td><td>void</td><td><ul><li>dst: Image *</li>
<li>centerX: int</li>
<li>centerY: int</li>
<li>radius: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawCircleV</b></td><td>Draw a filled circle within an image (Vector version)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>center: Vector2</li>
<li>radius: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawCircleLines</b></td><td>Draw circle outline within an image</td><td>void</td><td><ul><li>dst: Image *</li>
<li>centerX: int</li>
<li>centerY: int</li>
<li>radius: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawCircleLinesV</b></td><td>Draw circle outline within an image (Vector version)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>center: Vector2</li>
<li>radius: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawRectangle</b></td><td>Draw rectangle within an image</td><td>void</td><td><ul><li>dst: Image *</li>
<li>posX: int</li>
<li>posY: int</li>
<li>width: int</li>
<li>height: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawRectangleV</b></td><td>Draw rectangle within an image (Vector version)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>position: Vector2</li>
<li>size: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawRectangleRec</b></td><td>Draw rectangle within an image</td><td>void</td><td><ul><li>dst: Image *</li>
<li>rec: Rectangle</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawRectangleLines</b></td><td>Draw rectangle lines within an image</td><td>void</td><td><ul><li>dst: Image *</li>
<li>rec: Rectangle</li>
<li>thick: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDraw</b></td><td>Draw a source image within a destination image (tint applied to source)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>src: Image</li>
<li>srcRec: Rectangle</li>
<li>dstRec: Rectangle</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>ImageDrawText</b></td><td>Draw text (using default font) within an image (destination)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>text: const char *</li>
<li>posX: int</li>
<li>posY: int</li>
<li>fontSize: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>ImageDrawTextEx</b></td><td>Draw text (custom sprite font) within an image (destination)</td><td>void</td><td><ul><li>dst: Image *</li>
<li>font: Font</li>
<li>text: const char *</li>
<li>position: Vector2</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>LoadTexture</b></td><td>Load texture from file into GPU memory (VRAM)</td><td>Texture2D</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadTextureFromImage</b></td><td>Load texture from image data</td><td>Texture2D</td><td><ul><li>image: Image</li></ul></td></tr>
<tr><td><b>LoadTextureCubemap</b></td><td>Load cubemap from image, multiple image cubemap layouts supported</td><td>TextureCubemap</td><td><ul><li>image: Image</li>
<li>layout: int</li></ul></td></tr>
<tr><td><b>LoadRenderTexture</b></td><td>Load texture for rendering (framebuffer)</td><td>RenderTexture2D</td><td><ul><li>width: int</li>
<li>height: int</li></ul></td></tr>
<tr><td><b>IsTextureReady</b></td><td>Check if a texture is ready</td><td>bool</td><td><ul><li>texture: Texture2D</li></ul></td></tr>
<tr><td><b>UnloadTexture</b></td><td>Unload texture from GPU memory (VRAM)</td><td>void</td><td><ul><li>texture: Texture2D</li></ul></td></tr>
<tr><td><b>IsRenderTextureReady</b></td><td>Check if a render texture is ready</td><td>bool</td><td><ul><li>target: RenderTexture2D</li></ul></td></tr>
<tr><td><b>UnloadRenderTexture</b></td><td>Unload render texture from GPU memory (VRAM)</td><td>void</td><td><ul><li>target: RenderTexture2D</li></ul></td></tr>
<tr><td><b>UpdateTexture</b></td><td>Update GPU texture with new data</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>pixels: const void *</li></ul></td></tr>
<tr><td><b>UpdateTextureRec</b></td><td>Update GPU texture rectangle with new data</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>rec: Rectangle</li>
<li>pixels: const void *</li></ul></td></tr>
<tr><td><b>GenTextureMipmaps</b></td><td>Generate GPU mipmaps for a texture</td><td>void</td><td><ul><li>texture: Texture2D *</li></ul></td></tr>
<tr><td><b>SetTextureFilter</b></td><td>Set texture scaling filter mode</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>filter: int</li></ul></td></tr>
<tr><td><b>SetTextureWrap</b></td><td>Set texture wrapping mode</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>wrap: int</li></ul></td></tr>
<tr><td><b>DrawTexture</b></td><td>Draw a Texture2D</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>posX: int</li>
<li>posY: int</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTextureV</b></td><td>Draw a Texture2D with position defined as Vector2</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>position: Vector2</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTextureEx</b></td><td>Draw a Texture2D with extended parameters</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>position: Vector2</li>
<li>rotation: float</li>
<li>scale: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTextureRec</b></td><td>Draw a part of a texture defined by a rectangle</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>source: Rectangle</li>
<li>position: Vector2</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTexturePro</b></td><td>Draw a part of a texture defined by a rectangle with 'pro' parameters</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>source: Rectangle</li>
<li>dest: Rectangle</li>
<li>origin: Vector2</li>
<li>rotation: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTextureNPatch</b></td><td>Draws a texture (or part of it) that stretches or shrinks nicely</td><td>void</td><td><ul><li>texture: Texture2D</li>
<li>nPatchInfo: NPatchInfo</li>
<li>dest: Rectangle</li>
<li>origin: Vector2</li>
<li>rotation: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>Fade</b></td><td>Get color with alpha applied, alpha goes from 0.0f to 1.0f</td><td>Color</td><td><ul><li>color: Color</li>
<li>alpha: float</li></ul></td></tr>
<tr><td><b>ColorToInt</b></td><td>Get hexadecimal value for a Color</td><td>int</td><td><ul><li>color: Color</li></ul></td></tr>
<tr><td><b>ColorNormalize</b></td><td>Get Color normalized as float [0..1]</td><td>Vector4</td><td><ul><li>color: Color</li></ul></td></tr>
<tr><td><b>ColorFromNormalized</b></td><td>Get Color from normalized values [0..1]</td><td>Color</td><td><ul><li>normalized: Vector4</li></ul></td></tr>
<tr><td><b>ColorToHSV</b></td><td>Get HSV values for a Color, hue [0..360], saturation/value [0..1]</td><td>Vector3</td><td><ul><li>color: Color</li></ul></td></tr>
<tr><td><b>ColorFromHSV</b></td><td>Get a Color from HSV values, hue [0..360], saturation/value [0..1]</td><td>Color</td><td><ul><li>hue: float</li>
<li>saturation: float</li>
<li>value: float</li></ul></td></tr>
<tr><td><b>ColorTint</b></td><td>Get color multiplied with another color</td><td>Color</td><td><ul><li>color: Color</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>ColorBrightness</b></td><td>Get color with brightness correction, brightness factor goes from -1.0f to 1.0f</td><td>Color</td><td><ul><li>color: Color</li>
<li>factor: float</li></ul></td></tr>
<tr><td><b>ColorContrast</b></td><td>Get color with contrast correction, contrast values between -1.0f and 1.0f</td><td>Color</td><td><ul><li>color: Color</li>
<li>contrast: float</li></ul></td></tr>
<tr><td><b>ColorAlpha</b></td><td>Get color with alpha applied, alpha goes from 0.0f to 1.0f</td><td>Color</td><td><ul><li>color: Color</li>
<li>alpha: float</li></ul></td></tr>
<tr><td><b>ColorAlphaBlend</b></td><td>Get src alpha-blended into dst color with tint</td><td>Color</td><td><ul><li>dst: Color</li>
<li>src: Color</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>GetColor</b></td><td>Get Color structure from hexadecimal value</td><td>Color</td><td><ul><li>hexValue: unsigned int</li></ul></td></tr>
<tr><td><b>GetPixelColor</b></td><td>Get Color from a source pixel pointer of certain format</td><td>Color</td><td><ul><li>srcPtr: void *</li>
<li>format: int</li></ul></td></tr>
<tr><td><b>SetPixelColor</b></td><td>Set color formatted into destination pixel pointer</td><td>void</td><td><ul><li>dstPtr: void *</li>
<li>color: Color</li>
<li>format: int</li></ul></td></tr>
<tr><td><b>GetPixelDataSize</b></td><td>Get pixel data size in bytes for certain format</td><td>int</td><td><ul><li>width: int</li>
<li>height: int</li>
<li>format: int</li></ul></td></tr>
<tr><td><b>GetFontDefault</b></td><td>Get the default Font</td><td>Font</td></tr>
<tr><td><b>LoadFont</b></td><td>Load font from file into GPU memory (VRAM)</td><td>Font</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadFontEx</b></td><td>Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character setFont</td><td>Font</td><td><ul><li>fileName: const char *</li>
<li>fontSize: int</li>
<li>codepoints: int *</li>
<li>codepointCount: int</li></ul></td></tr>
<tr><td><b>LoadFontFromImage</b></td><td>Load font from Image (XNA style)</td><td>Font</td><td><ul><li>image: Image</li>
<li>key: Color</li>
<li>firstChar: int</li></ul></td></tr>
<tr><td><b>LoadFontFromMemory</b></td><td>Load font from memory buffer, fileType refers to extension: i.e. '.ttf'</td><td>Font</td><td><ul><li>fileType: const char *</li>
<li>fileData: const unsigned char *</li>
<li>dataSize: int</li>
<li>fontSize: int</li>
<li>codepoints: int *</li>
<li>codepointCount: int</li></ul></td></tr>
<tr><td><b>IsFontReady</b></td><td>Check if a font is ready</td><td>bool</td><td><ul><li>font: Font</li></ul></td></tr>
<tr><td><b>LoadFontData</b></td><td>Load font data for further use</td><td>GlyphInfo *</td><td><ul><li>fileData: const unsigned char *</li>
<li>dataSize: int</li>
<li>fontSize: int</li>
<li>codepoints: int *</li>
<li>codepointCount: int</li>
<li>type: int</li></ul></td></tr>
<tr><td><b>GenImageFontAtlas</b></td><td>Generate image font atlas using chars info</td><td>Image</td><td><ul><li>glyphs: const GlyphInfo *</li>
<li>glyphRecs: Rectangle **</li>
<li>glyphCount: int</li>
<li>fontSize: int</li>
<li>padding: int</li>
<li>packMethod: int</li></ul></td></tr>
<tr><td><b>UnloadFontData</b></td><td>Unload font chars info data (RAM)</td><td>void</td><td><ul><li>glyphs: GlyphInfo *</li>
<li>glyphCount: int</li></ul></td></tr>
<tr><td><b>UnloadFont</b></td><td>Unload font from GPU memory (VRAM)</td><td>void</td><td><ul><li>font: Font</li></ul></td></tr>
<tr><td><b>ExportFontAsCode</b></td><td>Export font as code file, returns true on success</td><td>bool</td><td><ul><li>font: Font</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>DrawFPS</b></td><td>Draw current FPS</td><td>void</td><td><ul><li>posX: int</li>
<li>posY: int</li></ul></td></tr>
<tr><td><b>DrawText</b></td><td>Draw text (using default font)</td><td>void</td><td><ul><li>text: const char *</li>
<li>posX: int</li>
<li>posY: int</li>
<li>fontSize: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawTextEx</b></td><td>Draw text using font and additional parameters</td><td>void</td><td><ul><li>font: Font</li>
<li>text: const char *</li>
<li>position: Vector2</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTextPro</b></td><td>Draw text using Font and pro parameters (rotation)</td><td>void</td><td><ul><li>font: Font</li>
<li>text: const char *</li>
<li>position: Vector2</li>
<li>origin: Vector2</li>
<li>rotation: float</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTextCodepoint</b></td><td>Draw one character (codepoint)</td><td>void</td><td><ul><li>font: Font</li>
<li>codepoint: int</li>
<li>position: Vector2</li>
<li>fontSize: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawTextCodepoints</b></td><td>Draw multiple character (codepoint)</td><td>void</td><td><ul><li>font: Font</li>
<li>codepoints: const int *</li>
<li>codepointCount: int</li>
<li>position: Vector2</li>
<li>fontSize: float</li>
<li>spacing: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>SetTextLineSpacing</b></td><td>Set vertical line spacing when drawing with line-breaks</td><td>void</td><td><ul><li>spacing: int</li></ul></td></tr>
<tr><td><b>MeasureText</b></td><td>Measure string width for default font</td><td>int</td><td><ul><li>text: const char *</li>
<li>fontSize: int</li></ul></td></tr>
<tr><td><b>MeasureTextEx</b></td><td>Measure string size for Font</td><td>Vector2</td><td><ul><li>font: Font</li>
<li>text: const char *</li>
<li>fontSize: float</li>
<li>spacing: float</li></ul></td></tr>
<tr><td><b>GetGlyphIndex</b></td><td>Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found</td><td>int</td><td><ul><li>font: Font</li>
<li>codepoint: int</li></ul></td></tr>
<tr><td><b>GetGlyphInfo</b></td><td>Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found</td><td>GlyphInfo</td><td><ul><li>font: Font</li>
<li>codepoint: int</li></ul></td></tr>
<tr><td><b>GetGlyphAtlasRec</b></td><td>Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found</td><td>Rectangle</td><td><ul><li>font: Font</li>
<li>codepoint: int</li></ul></td></tr>
<tr><td><b>LoadUTF8</b></td><td>Load UTF-8 text encoded from codepoints array</td><td>char *</td><td><ul><li>codepoints: const int *</li>
<li>length: int</li></ul></td></tr>
<tr><td><b>UnloadUTF8</b></td><td>Unload UTF-8 text encoded from codepoints array</td><td>void</td><td><ul><li>text: char *</li></ul></td></tr>
<tr><td><b>LoadCodepoints</b></td><td>Load all codepoints from a UTF-8 text string, codepoints count returned by parameter</td><td>int *</td><td><ul><li>text: const char *</li>
<li>count: int *</li></ul></td></tr>
<tr><td><b>UnloadCodepoints</b></td><td>Unload codepoints data from memory</td><td>void</td><td><ul><li>codepoints: int *</li></ul></td></tr>
<tr><td><b>GetCodepointCount</b></td><td>Get total number of codepoints in a UTF-8 encoded string</td><td>int</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>GetCodepoint</b></td><td>Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure</td><td>int</td><td><ul><li>text: const char *</li>
<li>codepointSize: int *</li></ul></td></tr>
<tr><td><b>GetCodepointNext</b></td><td>Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure</td><td>int</td><td><ul><li>text: const char *</li>
<li>codepointSize: int *</li></ul></td></tr>
<tr><td><b>GetCodepointPrevious</b></td><td>Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure</td><td>int</td><td><ul><li>text: const char *</li>
<li>codepointSize: int *</li></ul></td></tr>
<tr><td><b>CodepointToUTF8</b></td><td>Encode one codepoint into UTF-8 byte array (array length returned as parameter)</td><td>const char *</td><td><ul><li>codepoint: int</li>
<li>utf8Size: int *</li></ul></td></tr>
<tr><td><b>TextCopy</b></td><td>Copy one string to another, returns bytes copied</td><td>int</td><td><ul><li>dst: char *</li>
<li>src: const char *</li></ul></td></tr>
<tr><td><b>TextIsEqual</b></td><td>Check if two text string are equal</td><td>bool</td><td><ul><li>text1: const char *</li>
<li>text2: const char *</li></ul></td></tr>
<tr><td><b>TextLength</b></td><td>Get text length, checks for '\0' ending</td><td>unsigned int</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextFormat</b></td><td>Text formatting with variables (sprintf() style)</td><td>const char *</td><td><ul><li>text: const char *</li>
<li>args: ...</li></ul></td></tr>
<tr><td><b>TextSubtext</b></td><td>Get a piece of a text string</td><td>const char *</td><td><ul><li>text: const char *</li>
<li>position: int</li>
<li>length: int</li></ul></td></tr>
<tr><td><b>TextReplace</b></td><td>Replace text string (WARNING: memory must be freed!)</td><td>char *</td><td><ul><li>text: char *</li>
<li>replace: const char *</li>
<li>by: const char *</li></ul></td></tr>
<tr><td><b>TextInsert</b></td><td>Insert text in a position (WARNING: memory must be freed!)</td><td>char *</td><td><ul><li>text: const char *</li>
<li>insert: const char *</li>
<li>position: int</li></ul></td></tr>
<tr><td><b>TextJoin</b></td><td>Join text strings with delimiter</td><td>const char *</td><td><ul><li>textList: const char **</li>
<li>count: int</li>
<li>delimiter: const char *</li></ul></td></tr>
<tr><td><b>TextSplit</b></td><td>Split text into multiple strings</td><td>const char **</td><td><ul><li>text: const char *</li>
<li>delimiter: char</li>
<li>count: int *</li></ul></td></tr>
<tr><td><b>TextAppend</b></td><td>Append text at specific position and move cursor!</td><td>void</td><td><ul><li>text: char *</li>
<li>append: const char *</li>
<li>position: int *</li></ul></td></tr>
<tr><td><b>TextFindIndex</b></td><td>Find first text occurrence within a string</td><td>int</td><td><ul><li>text: const char *</li>
<li>find: const char *</li></ul></td></tr>
<tr><td><b>TextToUpper</b></td><td>Get upper case version of provided string</td><td>const char *</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextToLower</b></td><td>Get lower case version of provided string</td><td>const char *</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextToPascal</b></td><td>Get Pascal case notation version of provided string</td><td>const char *</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>TextToInteger</b></td><td>Get integer value from text (negative values not supported)</td><td>int</td><td><ul><li>text: const char *</li></ul></td></tr>
<tr><td><b>DrawLine3D</b></td><td>Draw a line in 3D world space</td><td>void</td><td><ul><li>startPos: Vector3</li>
<li>endPos: Vector3</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawPoint3D</b></td><td>Draw a point in 3D space, actually a small line</td><td>void</td><td><ul><li>position: Vector3</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCircle3D</b></td><td>Draw a circle in 3D world space</td><td>void</td><td><ul><li>center: Vector3</li>
<li>radius: float</li>
<li>rotationAxis: Vector3</li>
<li>rotationAngle: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawTriangle3D</b></td><td>Draw a color-filled triangle (vertex in counter-clockwise order!)</td><td>void</td><td><ul><li>v1: Vector3</li>
<li>v2: Vector3</li>
<li>v3: Vector3</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawTriangleStrip3D</b></td><td>Draw a triangle strip defined by points</td><td>void</td><td><ul><li>points: Vector3 *</li>
<li>pointCount: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCube</b></td><td>Draw cube</td><td>void</td><td><ul><li>position: Vector3</li>
<li>width: float</li>
<li>height: float</li>
<li>length: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCubeV</b></td><td>Draw cube (Vector version)</td><td>void</td><td><ul><li>position: Vector3</li>
<li>size: Vector3</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCubeWires</b></td><td>Draw cube wires</td><td>void</td><td><ul><li>position: Vector3</li>
<li>width: float</li>
<li>height: float</li>
<li>length: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCubeWiresV</b></td><td>Draw cube wires (Vector version)</td><td>void</td><td><ul><li>position: Vector3</li>
<li>size: Vector3</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSphere</b></td><td>Draw sphere</td><td>void</td><td><ul><li>centerPos: Vector3</li>
<li>radius: float</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSphereEx</b></td><td>Draw sphere with extended parameters</td><td>void</td><td><ul><li>centerPos: Vector3</li>
<li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawSphereWires</b></td><td>Draw sphere wires</td><td>void</td><td><ul><li>centerPos: Vector3</li>
<li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCylinder</b></td><td>Draw a cylinder/cone</td><td>void</td><td><ul><li>position: Vector3</li>
<li>radiusTop: float</li>
<li>radiusBottom: float</li>
<li>height: float</li>
<li>slices: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCylinderEx</b></td><td>Draw a cylinder with base at startPos and top at endPos</td><td>void</td><td><ul><li>startPos: Vector3</li>
<li>endPos: Vector3</li>
<li>startRadius: float</li>
<li>endRadius: float</li>
<li>sides: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCylinderWires</b></td><td>Draw a cylinder/cone wires</td><td>void</td><td><ul><li>position: Vector3</li>
<li>radiusTop: float</li>
<li>radiusBottom: float</li>
<li>height: float</li>
<li>slices: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCylinderWiresEx</b></td><td>Draw a cylinder wires with base at startPos and top at endPos</td><td>void</td><td><ul><li>startPos: Vector3</li>
<li>endPos: Vector3</li>
<li>startRadius: float</li>
<li>endRadius: float</li>
<li>sides: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCapsule</b></td><td>Draw a capsule with the center of its sphere caps at startPos and endPos</td><td>void</td><td><ul><li>startPos: Vector3</li>
<li>endPos: Vector3</li>
<li>radius: float</li>
<li>slices: int</li>
<li>rings: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawCapsuleWires</b></td><td>Draw capsule wireframe with the center of its sphere caps at startPos and endPos</td><td>void</td><td><ul><li>startPos: Vector3</li>
<li>endPos: Vector3</li>
<li>radius: float</li>
<li>slices: int</li>
<li>rings: int</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawPlane</b></td><td>Draw a plane XZ</td><td>void</td><td><ul><li>centerPos: Vector3</li>
<li>size: Vector2</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawRay</b></td><td>Draw a ray line</td><td>void</td><td><ul><li>ray: Ray</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawGrid</b></td><td>Draw a grid (centered at (0, 0, 0))</td><td>void</td><td><ul><li>slices: int</li>
<li>spacing: float</li></ul></td></tr>
<tr><td><b>LoadModel</b></td><td>Load model from files (meshes and materials)</td><td>Model</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadModelFromMesh</b></td><td>Load model from generated mesh (default material)</td><td>Model</td><td><ul><li>mesh: Mesh</li></ul></td></tr>
<tr><td><b>IsModelReady</b></td><td>Check if a model is ready</td><td>bool</td><td><ul><li>model: Model</li></ul></td></tr>
<tr><td><b>UnloadModel</b></td><td>Unload model (including meshes) from memory (RAM and/or VRAM)</td><td>void</td><td><ul><li>model: Model</li></ul></td></tr>
<tr><td><b>GetModelBoundingBox</b></td><td>Compute model bounding box limits (considers all meshes)</td><td>BoundingBox</td><td><ul><li>model: Model</li></ul></td></tr>
<tr><td><b>DrawModel</b></td><td>Draw a model (with texture if set)</td><td>void</td><td><ul><li>model: Model</li>
<li>position: Vector3</li>
<li>scale: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawModelEx</b></td><td>Draw a model with extended parameters</td><td>void</td><td><ul><li>model: Model</li>
<li>position: Vector3</li>
<li>rotationAxis: Vector3</li>
<li>rotationAngle: float</li>
<li>scale: Vector3</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawModelWires</b></td><td>Draw a model wires (with texture if set)</td><td>void</td><td><ul><li>model: Model</li>
<li>position: Vector3</li>
<li>scale: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawModelWiresEx</b></td><td>Draw a model wires (with texture if set) with extended parameters</td><td>void</td><td><ul><li>model: Model</li>
<li>position: Vector3</li>
<li>rotationAxis: Vector3</li>
<li>rotationAngle: float</li>
<li>scale: Vector3</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawBoundingBox</b></td><td>Draw bounding box (wires)</td><td>void</td><td><ul><li>box: BoundingBox</li>
<li>color: Color</li></ul></td></tr>
<tr><td><b>DrawBillboard</b></td><td>Draw a billboard texture</td><td>void</td><td><ul><li>camera: Camera</li>
<li>texture: Texture2D</li>
<li>position: Vector3</li>
<li>size: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawBillboardRec</b></td><td>Draw a billboard texture defined by source</td><td>void</td><td><ul><li>camera: Camera</li>
<li>texture: Texture2D</li>
<li>source: Rectangle</li>
<li>position: Vector3</li>
<li>size: Vector2</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>DrawBillboardPro</b></td><td>Draw a billboard texture defined by source and rotation</td><td>void</td><td><ul><li>camera: Camera</li>
<li>texture: Texture2D</li>
<li>source: Rectangle</li>
<li>position: Vector3</li>
<li>up: Vector3</li>
<li>size: Vector2</li>
<li>origin: Vector2</li>
<li>rotation: float</li>
<li>tint: Color</li></ul></td></tr>
<tr><td><b>UploadMesh</b></td><td>Upload mesh vertex data in GPU and provide VAO/VBO ids</td><td>void</td><td><ul><li>mesh: Mesh *</li>
<li>dynamic: bool</li></ul></td></tr>
<tr><td><b>UpdateMeshBuffer</b></td><td>Update mesh vertex data in GPU for a specific buffer index</td><td>void</td><td><ul><li>mesh: Mesh</li>
<li>index: int</li>
<li>data: const void *</li>
<li>dataSize: int</li>
<li>offset: int</li></ul></td></tr>
<tr><td><b>UnloadMesh</b></td><td>Unload mesh data from CPU and GPU</td><td>void</td><td><ul><li>mesh: Mesh</li></ul></td></tr>
<tr><td><b>DrawMesh</b></td><td>Draw a 3d mesh with material and transform</td><td>void</td><td><ul><li>mesh: Mesh</li>
<li>material: Material</li>
<li>transform: Matrix</li></ul></td></tr>
<tr><td><b>DrawMeshInstanced</b></td><td>Draw multiple mesh instances with material and different transforms</td><td>void</td><td><ul><li>mesh: Mesh</li>
<li>material: Material</li>
<li>transforms: const Matrix *</li>
<li>instances: int</li></ul></td></tr>
<tr><td><b>ExportMesh</b></td><td>Export mesh data to file, returns true on success</td><td>bool</td><td><ul><li>mesh: Mesh</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>GetMeshBoundingBox</b></td><td>Compute mesh bounding box limits</td><td>BoundingBox</td><td><ul><li>mesh: Mesh</li></ul></td></tr>
<tr><td><b>GenMeshTangents</b></td><td>Compute mesh tangents</td><td>void</td><td><ul><li>mesh: Mesh *</li></ul></td></tr>
<tr><td><b>GenMeshPoly</b></td><td>Generate polygonal mesh</td><td>Mesh</td><td><ul><li>sides: int</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>GenMeshPlane</b></td><td>Generate plane mesh (with subdivisions)</td><td>Mesh</td><td><ul><li>width: float</li>
<li>length: float</li>
<li>resX: int</li>
<li>resZ: int</li></ul></td></tr>
<tr><td><b>GenMeshCube</b></td><td>Generate cuboid mesh</td><td>Mesh</td><td><ul><li>width: float</li>
<li>height: float</li>
<li>length: float</li></ul></td></tr>
<tr><td><b>GenMeshSphere</b></td><td>Generate sphere mesh (standard sphere)</td><td>Mesh</td><td><ul><li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>GenMeshHemiSphere</b></td><td>Generate half-sphere mesh (no bottom cap)</td><td>Mesh</td><td><ul><li>radius: float</li>
<li>rings: int</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>GenMeshCylinder</b></td><td>Generate cylinder mesh</td><td>Mesh</td><td><ul><li>radius: float</li>
<li>height: float</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>GenMeshCone</b></td><td>Generate cone/pyramid mesh</td><td>Mesh</td><td><ul><li>radius: float</li>
<li>height: float</li>
<li>slices: int</li></ul></td></tr>
<tr><td><b>GenMeshTorus</b></td><td>Generate torus mesh</td><td>Mesh</td><td><ul><li>radius: float</li>
<li>size: float</li>
<li>radSeg: int</li>
<li>sides: int</li></ul></td></tr>
<tr><td><b>GenMeshKnot</b></td><td>Generate trefoil knot mesh</td><td>Mesh</td><td><ul><li>radius: float</li>
<li>size: float</li>
<li>radSeg: int</li>
<li>sides: int</li></ul></td></tr>
<tr><td><b>GenMeshHeightmap</b></td><td>Generate heightmap mesh from image data</td><td>Mesh</td><td><ul><li>heightmap: Image</li>
<li>size: Vector3</li></ul></td></tr>
<tr><td><b>GenMeshCubicmap</b></td><td>Generate cubes-based map mesh from image data</td><td>Mesh</td><td><ul><li>cubicmap: Image</li>
<li>cubeSize: Vector3</li></ul></td></tr>
<tr><td><b>LoadMaterials</b></td><td>Load materials from model file</td><td>Material *</td><td><ul><li>fileName: const char *</li>
<li>materialCount: int *</li></ul></td></tr>
<tr><td><b>LoadMaterialDefault</b></td><td>Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)</td><td>Material</td></tr>
<tr><td><b>IsMaterialReady</b></td><td>Check if a material is ready</td><td>bool</td><td><ul><li>material: Material</li></ul></td></tr>
<tr><td><b>UnloadMaterial</b></td><td>Unload material from GPU memory (VRAM)</td><td>void</td><td><ul><li>material: Material</li></ul></td></tr>
<tr><td><b>SetMaterialTexture</b></td><td>Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)</td><td>void</td><td><ul><li>material: Material *</li>
<li>mapType: int</li>
<li>texture: Texture2D</li></ul></td></tr>
<tr><td><b>SetModelMeshMaterial</b></td><td>Set material for a mesh</td><td>void</td><td><ul><li>model: Model *</li>
<li>meshId: int</li>
<li>materialId: int</li></ul></td></tr>
<tr><td><b>LoadModelAnimations</b></td><td>Load model animations from file</td><td>ModelAnimation *</td><td><ul><li>fileName: const char *</li>
<li>animCount: int *</li></ul></td></tr>
<tr><td><b>UpdateModelAnimation</b></td><td>Update model animation pose</td><td>void</td><td><ul><li>model: Model</li>
<li>anim: ModelAnimation</li>
<li>frame: int</li></ul></td></tr>
<tr><td><b>UnloadModelAnimation</b></td><td>Unload animation data</td><td>void</td><td><ul><li>anim: ModelAnimation</li></ul></td></tr>
<tr><td><b>UnloadModelAnimations</b></td><td>Unload animation array data</td><td>void</td><td><ul><li>animations: ModelAnimation *</li>
<li>animCount: int</li></ul></td></tr>
<tr><td><b>IsModelAnimationValid</b></td><td>Check model animation skeleton match</td><td>bool</td><td><ul><li>model: Model</li>
<li>anim: ModelAnimation</li></ul></td></tr>
<tr><td><b>CheckCollisionSpheres</b></td><td>Check collision between two spheres</td><td>bool</td><td><ul><li>center1: Vector3</li>
<li>radius1: float</li>
<li>center2: Vector3</li>
<li>radius2: float</li></ul></td></tr>
<tr><td><b>CheckCollisionBoxes</b></td><td>Check collision between two bounding boxes</td><td>bool</td><td><ul><li>box1: BoundingBox</li>
<li>box2: BoundingBox</li></ul></td></tr>
<tr><td><b>CheckCollisionBoxSphere</b></td><td>Check collision between box and sphere</td><td>bool</td><td><ul><li>box: BoundingBox</li>
<li>center: Vector3</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>GetRayCollisionSphere</b></td><td>Get collision info between ray and sphere</td><td>RayCollision</td><td><ul><li>ray: Ray</li>
<li>center: Vector3</li>
<li>radius: float</li></ul></td></tr>
<tr><td><b>GetRayCollisionBox</b></td><td>Get collision info between ray and box</td><td>RayCollision</td><td><ul><li>ray: Ray</li>
<li>box: BoundingBox</li></ul></td></tr>
<tr><td><b>GetRayCollisionMesh</b></td><td>Get collision info between ray and mesh</td><td>RayCollision</td><td><ul><li>ray: Ray</li>
<li>mesh: Mesh</li>
<li>transform: Matrix</li></ul></td></tr>
<tr><td><b>GetRayCollisionTriangle</b></td><td>Get collision info between ray and triangle</td><td>RayCollision</td><td><ul><li>ray: Ray</li>
<li>p1: Vector3</li>
<li>p2: Vector3</li>
<li>p3: Vector3</li></ul></td></tr>
<tr><td><b>GetRayCollisionQuad</b></td><td>Get collision info between ray and quad</td><td>RayCollision</td><td><ul><li>ray: Ray</li>
<li>p1: Vector3</li>
<li>p2: Vector3</li>
<li>p3: Vector3</li>
<li>p4: Vector3</li></ul></td></tr>
<tr><td><b>InitAudioDevice</b></td><td>Initialize audio device and context</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>CloseAudioDevice</b></td><td>Close the audio device and context</td><td>void</td><td><ul></ul></td></tr>
<tr><td><b>IsAudioDeviceReady</b></td><td>Check if audio device has been initialized successfully</td><td>bool</td><td><ul></ul></td></tr>
<tr><td><b>SetMasterVolume</b></td><td>Set master volume (listener)</td><td>void</td><td><ul><li>volume: float</li></ul></td></tr>
<tr><td><b>GetMasterVolume</b></td><td>Get master volume (listener)</td><td>float</td><td><ul></ul></td></tr>
<tr><td><b>LoadWave</b></td><td>Load wave data from file</td><td>Wave</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadWaveFromMemory</b></td><td>Load wave from memory buffer, fileType refers to extension: i.e. '.wav'</td><td>Wave</td><td><ul><li>fileType: const char *</li>
<li>fileData: const unsigned char *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>IsWaveReady</b></td><td>Checks if wave data is ready</td><td>bool</td><td><ul><li>wave: Wave</li></ul></td></tr>
<tr><td><b>LoadSound</b></td><td>Load sound from file</td><td>Sound</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadSoundFromWave</b></td><td>Load sound from wave data</td><td>Sound</td><td><ul><li>wave: Wave</li></ul></td></tr>
<tr><td><b>LoadSoundAlias</b></td><td>Create a new sound that shares the same sample data as the source sound, does not own the sound data</td><td>Sound</td><td><ul><li>source: Sound</li></ul></td></tr>
<tr><td><b>IsSoundReady</b></td><td>Checks if a sound is ready</td><td>bool</td><td><ul><li>sound: Sound</li></ul></td></tr>
<tr><td><b>UpdateSound</b></td><td>Update sound buffer with new data</td><td>void</td><td><ul><li>sound: Sound</li>
<li>data: const void *</li>
<li>sampleCount: int</li></ul></td></tr>
<tr><td><b>UnloadWave</b></td><td>Unload wave data</td><td>void</td><td><ul><li>wave: Wave</li></ul></td></tr>
<tr><td><b>UnloadSound</b></td><td>Unload sound</td><td>void</td><td><ul><li>sound: Sound</li></ul></td></tr>
<tr><td><b>UnloadSoundAlias</b></td><td>Unload a sound alias (does not deallocate sample data)</td><td>void</td><td><ul><li>alias: Sound</li></ul></td></tr>
<tr><td><b>ExportWave</b></td><td>Export wave data to file, returns true on success</td><td>bool</td><td><ul><li>wave: Wave</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>ExportWaveAsCode</b></td><td>Export wave sample data to code (.h), returns true on success</td><td>bool</td><td><ul><li>wave: Wave</li>
<li>fileName: const char *</li></ul></td></tr>
<tr><td><b>PlaySound</b></td><td>Play a sound</td><td>void</td><td><ul><li>sound: Sound</li></ul></td></tr>
<tr><td><b>StopSound</b></td><td>Stop playing a sound</td><td>void</td><td><ul><li>sound: Sound</li></ul></td></tr>
<tr><td><b>PauseSound</b></td><td>Pause a sound</td><td>void</td><td><ul><li>sound: Sound</li></ul></td></tr>
<tr><td><b>ResumeSound</b></td><td>Resume a paused sound</td><td>void</td><td><ul><li>sound: Sound</li></ul></td></tr>
<tr><td><b>IsSoundPlaying</b></td><td>Check if a sound is currently playing</td><td>bool</td><td><ul><li>sound: Sound</li></ul></td></tr>
<tr><td><b>SetSoundVolume</b></td><td>Set volume for a sound (1.0 is max level)</td><td>void</td><td><ul><li>sound: Sound</li>
<li>volume: float</li></ul></td></tr>
<tr><td><b>SetSoundPitch</b></td><td>Set pitch for a sound (1.0 is base level)</td><td>void</td><td><ul><li>sound: Sound</li>
<li>pitch: float</li></ul></td></tr>
<tr><td><b>SetSoundPan</b></td><td>Set pan for a sound (0.5 is center)</td><td>void</td><td><ul><li>sound: Sound</li>
<li>pan: float</li></ul></td></tr>
<tr><td><b>WaveCopy</b></td><td>Copy a wave to a new wave</td><td>Wave</td><td><ul><li>wave: Wave</li></ul></td></tr>
<tr><td><b>WaveCrop</b></td><td>Crop a wave to defined samples range</td><td>void</td><td><ul><li>wave: Wave *</li>
<li>initSample: int</li>
<li>finalSample: int</li></ul></td></tr>
<tr><td><b>WaveFormat</b></td><td>Convert wave data to desired format</td><td>void</td><td><ul><li>wave: Wave *</li>
<li>sampleRate: int</li>
<li>sampleSize: int</li>
<li>channels: int</li></ul></td></tr>
<tr><td><b>LoadWaveSamples</b></td><td>Load samples data from wave as a 32bit float data array</td><td>float *</td><td><ul><li>wave: Wave</li></ul></td></tr>
<tr><td><b>UnloadWaveSamples</b></td><td>Unload samples data loaded with LoadWaveSamples()</td><td>void</td><td><ul><li>samples: float *</li></ul></td></tr>
<tr><td><b>LoadMusicStream</b></td><td>Load music stream from file</td><td>Music</td><td><ul><li>fileName: const char *</li></ul></td></tr>
<tr><td><b>LoadMusicStreamFromMemory</b></td><td>Load music stream from data</td><td>Music</td><td><ul><li>fileType: const char *</li>
<li>data: const unsigned char *</li>
<li>dataSize: int</li></ul></td></tr>
<tr><td><b>IsMusicReady</b></td><td>Checks if a music stream is ready</td><td>bool</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>UnloadMusicStream</b></td><td>Unload music stream</td><td>void</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>PlayMusicStream</b></td><td>Start music playing</td><td>void</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>IsMusicStreamPlaying</b></td><td>Check if music is playing</td><td>bool</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>UpdateMusicStream</b></td><td>Updates buffers for music streaming</td><td>void</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>StopMusicStream</b></td><td>Stop music playing</td><td>void</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>PauseMusicStream</b></td><td>Pause music playing</td><td>void</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>ResumeMusicStream</b></td><td>Resume playing paused music</td><td>void</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>SeekMusicStream</b></td><td>Seek music to a position (in seconds)</td><td>void</td><td><ul><li>music: Music</li>
<li>position: float</li></ul></td></tr>
<tr><td><b>SetMusicVolume</b></td><td>Set volume for music (1.0 is max level)</td><td>void</td><td><ul><li>music: Music</li>
<li>volume: float</li></ul></td></tr>
<tr><td><b>SetMusicPitch</b></td><td>Set pitch for a music (1.0 is base level)</td><td>void</td><td><ul><li>music: Music</li>
<li>pitch: float</li></ul></td></tr>
<tr><td><b>SetMusicPan</b></td><td>Set pan for a music (0.5 is center)</td><td>void</td><td><ul><li>music: Music</li>
<li>pan: float</li></ul></td></tr>
<tr><td><b>GetMusicTimeLength</b></td><td>Get music time length (in seconds)</td><td>float</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>GetMusicTimePlayed</b></td><td>Get current music time played (in seconds)</td><td>float</td><td><ul><li>music: Music</li></ul></td></tr>
<tr><td><b>LoadAudioStream</b></td><td>Load audio stream (to stream raw audio pcm data)</td><td>AudioStream</td><td><ul><li>sampleRate: unsigned int</li>
<li>sampleSize: unsigned int</li>
<li>channels: unsigned int</li></ul></td></tr>
<tr><td><b>IsAudioStreamReady</b></td><td>Checks if an audio stream is ready</td><td>bool</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>UnloadAudioStream</b></td><td>Unload audio stream and free memory</td><td>void</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>UpdateAudioStream</b></td><td>Update audio stream buffers with data</td><td>void</td><td><ul><li>stream: AudioStream</li>
<li>data: const void *</li>
<li>frameCount: int</li></ul></td></tr>
<tr><td><b>IsAudioStreamProcessed</b></td><td>Check if any audio stream buffers requires refill</td><td>bool</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>PlayAudioStream</b></td><td>Play audio stream</td><td>void</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>PauseAudioStream</b></td><td>Pause audio stream</td><td>void</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>ResumeAudioStream</b></td><td>Resume audio stream</td><td>void</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>IsAudioStreamPlaying</b></td><td>Check if audio stream is playing</td><td>bool</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>StopAudioStream</b></td><td>Stop audio stream</td><td>void</td><td><ul><li>stream: AudioStream</li></ul></td></tr>
<tr><td><b>SetAudioStreamVolume</b></td><td>Set volume for audio stream (1.0 is max level)</td><td>void</td><td><ul><li>stream: AudioStream</li>
<li>volume: float</li></ul></td></tr>
<tr><td><b>SetAudioStreamPitch</b></td><td>Set pitch for audio stream (1.0 is base level)</td><td>void</td><td><ul><li>stream: AudioStream</li>
<li>pitch: float</li></ul></td></tr>
<tr><td><b>SetAudioStreamPan</b></td><td>Set pan for audio stream (0.5 is centered)</td><td>void</td><td><ul><li>stream: AudioStream</li>
<li>pan: float</li></ul></td></tr>
<tr><td><b>SetAudioStreamBufferSizeDefault</b></td><td>Default size for new audio streams</td><td>void</td><td><ul><li>size: int</li></ul></td></tr>
<tr><td><b>SetAudioStreamCallback</b></td><td>Audio thread callback to request new data</td><td>void</td><td><ul><li>stream: AudioStream</li>
<li>callback: AudioCallback</li></ul></td></tr>
<tr><td><b>AttachAudioStreamProcessor</b></td><td>Attach audio stream processor to stream, receives the samples as <float>s</td><td>void</td><td><ul><li>stream: AudioStream</li>
<li>processor: AudioCallback</li></ul></td></tr>
<tr><td><b>DetachAudioStreamProcessor</b></td><td>Detach audio stream processor from stream</td><td>void</td><td><ul><li>stream: AudioStream</li>
<li>processor: AudioCallback</li></ul></td></tr>
<tr><td><b>AttachAudioMixedProcessor</b></td><td>Attach audio stream processor to the entire audio pipeline, receives the samples as <float>s</td><td>void</td><td><ul><li>processor: AudioCallback</li></ul></td></tr>
<tr><td><b>DetachAudioMixedProcessor</b></td><td>Detach audio stream processor from the entire audio pipeline</td><td>void</td><td><ul><li>processor: AudioCallback</li></ul></td></tr>
</table>
  
	</body>
</html>
	